    @Override
    protected void onResume() {
        super.onResume();

        // Listen to key presses and only start search after user paused to avoid excessive redrawing on the screen.
        subscription = RxTextView.textChangeEvents(searchInputView)
                .debounce(200, TimeUnit.MILLISECONDS) // default Scheduler is Schedulers.computation()
                .observeOn(AndroidSchedulers.mainThread()) // Needed to access Realm data
                .flatMap(new Func1<TextViewTextChangeEvent, rx.Observable<RealmResults<Person>>>() {
                    @Override
                    public rx.Observable<RealmResults<Person>> call(TextViewTextChangeEvent event) {
                        // Use Async API to move Realm queries off the main thread.
                        // Realm currently doesn't support the standard Schedulers.
                        return realm.where(Person.class)
                                .beginsWith("name", event.text().toString())
                                .findAllSortedAsync("name").observable();
                    }
                })
                .filter(new Func1<RealmResults<Person>, Boolean>() {
                    @Override
                    public Boolean call(RealmResults<Person> persons) {
                        // Only continue once data is actually loaded
                        // RealmObservables will emit the unloaded (empty) list as it's first item
                        return persons.isLoaded();
                    }
                })
                .subscribe(new Action1<RealmResults<Person>>() {
                    @Override
                    public void call(RealmResults<Person> persons) {
                        searchResultsView.removeAllViews();
                        for (Person person : persons) {
                            TextView view = new TextView(ThrottleSearchActivity.this);
                            view.setText(person.getName());
                            searchResultsView.addView(view);
                        }
                    }
                }, new Action1<Throwable>() {
                    @Override
                    public void call(Throwable throwable) {
                        throwable.printStackTrace();
                    }
                });
    }

