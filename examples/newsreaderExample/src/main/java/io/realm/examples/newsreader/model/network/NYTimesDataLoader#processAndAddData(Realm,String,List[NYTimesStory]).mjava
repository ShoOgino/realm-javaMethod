    // Converts data into a usable format and save it to Realm
    private void processAndAddData(final Realm realm, final String sectionKey, final List<NYTimesStory> stories) {
        if (stories.isEmpty()) return;

        realm.executeTransactionAsync(r -> {
            for (NYTimesStory story : stories) {
                Date parsedPublishedDate = inputDateFormat.parse(story.getPublishedDate(), new ParsePosition(0));
                story.setSortTimeStamp(parsedPublishedDate.getTime());
                story.setPublishedDate(outputDateFormat.format(parsedPublishedDate));

                // Find existing story in Realm (if any)
                // If it exists, we need to merge the local state with the remote, because the local state
                // contains more info than is available on the server.
                NYTimesStory persistedStory = r.where(NYTimesStory.class).equalTo(NYTimesStory.URL, story.getUrl()).findFirst();
                if (persistedStory != null) {
                    // Only local state is the `read` boolean.
                    story.setRead(persistedStory.isRead());
                }

                // Only create or update the local story if needed
                if (persistedStory == null || !persistedStory.getUpdatedDate().equals(story.getUpdatedDate())) {
                    story.setApiSection(sectionKey);
                    r.copyToRealmOrUpdate(story);
                }
            }
        }, throwable -> Timber.e(throwable, "Could not save data"));
    }

