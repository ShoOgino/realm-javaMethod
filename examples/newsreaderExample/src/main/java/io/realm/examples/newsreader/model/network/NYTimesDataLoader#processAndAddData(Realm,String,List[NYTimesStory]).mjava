    // Converts data into a usable format and save it to Realm
    private void processAndAddData(final Realm realm, final String sectionKey, final List<NYTimesStory> stories) {
        if (stories.isEmpty()) return;

        realm.executeTransactionAsync(new Realm.Transaction() {
            @Override
            public void execute(Realm realm) {
                for (NYTimesStory story : stories) {
                    Date parsedPublishedDate = inputDateFormat.parse(story.getPublishedDate(), new ParsePosition(0));
                    story.setSortTimeStamp(parsedPublishedDate.getTime());
                    story.setPublishedDate(outputDateFormat.format(parsedPublishedDate));

                    // Find existing story in Realm (if any)
                    // If it exists, we need to merge the local state with the remote, because the local state
                    // contains more info than is available on the server.
                    NYTimesStory persistedStory = realm.where(NYTimesStory.class).equalTo(NYTimesStory.URL, story.getUrl()).findFirst();
                    if (persistedStory != null) {
                        // Only local state is the `read` boolean.
                        story.setRead(persistedStory.isRead());
                   }

                    // Only create or update the local story if needed
                    if (persistedStory == null || !persistedStory.getUpdatedDate().equals(story.getUpdatedDate())) {
                        story.setApiSection(sectionKey);
                        realm.copyToRealmOrUpdate(story);
                    }
                }
            }
        }, new Realm.Transaction.OnError() {
            @Override
            public void onError(Throwable throwable) {
                Timber.e(throwable, "Could not save data");
            }
        });
    }

