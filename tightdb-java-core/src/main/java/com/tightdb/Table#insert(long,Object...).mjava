	public void insert(long rowIndex, Object... values) {
		if (immutable) throwImmutable();
		
		// Check index
		long size = size();
		if (rowIndex > size) {
			throw new IllegalArgumentException("rowIndex " + String.valueOf(rowIndex) + 
					" must be <= table.size() " + String.valueOf(size) + ".");
		}
		
		// Check values types
		int columns = (int)getColumnCount();
		if (columns != values.length) {
			throw new IllegalArgumentException("The number of value parameters (" + 
					String.valueOf(values.length) + 
					") does not match the number of columns in the table (" + 
					String.valueOf(columns) + ").");
		}		
		ColumnType colTypes[] = new ColumnType[columns];
		for (int columnIndex = 0; columnIndex < columns; columnIndex++) {  
		    Object value = values[columnIndex];
			ColumnType colType = getColumnType(columnIndex);
			colTypes[columnIndex] = colType;
			if (!colType.matchObject(value)) {
				throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) + 
						". Expected a value compatible with column type " + colType + ", but got " + value.getClass() + ".");
			}
		}		
		
		// Insert values
		for (long columnIndex = 0; columnIndex < columns; columnIndex++) {  
			Object value = values[(int)columnIndex];
			switch (colTypes[(int)columnIndex]) { 
			case ColumnTypeBool:	
				nativeInsertBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
				break;
			case ColumnTypeInt:	
				nativeInsertLong(nativePtr, columnIndex, rowIndex, ((Number)value).longValue());
				break;
			case ColumnTypeString:
				nativeInsertString(nativePtr, columnIndex, rowIndex, (String)value);
				break;
			case ColumnTypeDate:
				nativeInsertDate(nativePtr, columnIndex, rowIndex, ((Date)value).getTime()/1000);
				break;
			case ColumnTypeMixed:
				nativeInsertMixed(nativePtr, columnIndex, rowIndex, Mixed.mixedValue(value));
				break;
			case ColumnTypeBinary:
				if (value instanceof byte[])
					nativeInsertByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
				else if (value instanceof ByteBuffer)
					nativeInsertByteBuffer(nativePtr, columnIndex, rowIndex, (ByteBuffer)value);
				break;
			case ColumnTypeTable:
				nativeInsertSubTable(nativePtr, columnIndex, rowIndex);
				if (value != null) {
					// insert rows in subtable recursively
					Table subtable = getSubTableDuringInsert(columnIndex, rowIndex);
					int rows = ((Object[])value).length;
					for (int i=0; i<rows; ++i) {
						Object rowArr = ((Object[])value)[i];
						subtable.insert(i, (Object[])rowArr);
					}
				}
				break;
			default:
				throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int)columnIndex]));
			}
		}
		insertDone();
	}

