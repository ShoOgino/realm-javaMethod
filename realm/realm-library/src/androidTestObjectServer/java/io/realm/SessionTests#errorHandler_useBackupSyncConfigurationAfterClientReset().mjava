    // Check that we can open the backup file without using the provided SyncConfiguration,
    // this might be the case if the user decide to act upon the client reset later (providing s/he
    // persisted the location of the file)
    @Test
    @RunTestInLooperThread
    public void errorHandler_useBackupSyncConfigurationAfterClientReset() {
        SyncUser user = createTestUser();
        String url = "realm://objectserver.realm.io/default";
        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                .clientResyncMode(ClientResyncMode.MANUAL)
                .errorHandler((session, error) -> {
                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
                        fail("Wrong error " + error.toString());
                        return;
                    }

                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;
                    // Execute Client Reset
                    looperThread.closeTestRealms();
                    handler.executeClientReset();

                    // Validate that files have been moved
                    assertFalse(handler.getOriginalFile().exists());
                    assertTrue(handler.getBackupFile().exists());

                    String backupFile = handler.getBackupFile().getAbsolutePath();

                    // this SyncConf doesn't specify any module, it will throw a migration required
                    // exception since the backup Realm contain only StringOnly table
                    RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);

                    try {
                        Realm.getInstance(backupRealmConfiguration);
                        fail("Expected to throw a Migration required");
                    } catch (RealmMigrationNeededException expected) {
                    }

                    // opening a DynamicRealm will work though
                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);

                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
                    assertEquals(1, all.size());
                    assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));

                    // make sure we can't write to it (read-only Realm)
                    try {
                        dynamicRealm.beginTransaction();
                        fail("Can't perform transactions on read-only Realms");
                    } catch (IllegalStateException expected) {
                    }
                    dynamicRealm.close();

                    try {
                        SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);
                        fail("Expected to throw java.lang.Class is not a RealmModule");
                    } catch (IllegalArgumentException expected) {
                    }

                    // specifying the module will allow to open the typed Realm
                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());
                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
                    assertFalse(backupRealm.isEmpty());
                    assertEquals(1, backupRealm.where(StringOnly.class).count());
                    RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();
                    assertEquals("Foo", allSorted.get(0).getChars());
                    backupRealm.close();

                    looperThread.testComplete();
                })
                .modules(new StringOnlyModule())
                .build();

        Realm realm = Realm.getInstance(config);
        realm.beginTransaction();
        realm.createObject(StringOnly.class).setChars("Foo");
        realm.commitTransaction();

        looperThread.addTestRealm(realm);

        // Trigger error
        SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));
    }

