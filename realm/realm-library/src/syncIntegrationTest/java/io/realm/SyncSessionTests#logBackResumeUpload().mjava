    // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
    @Test
    public void logBackResumeUpload() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        final String uniqueName = UUID.randomUUID().toString();
        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);

        final SyncConfiguration syncConfiguration = configFactory
                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                .modules(new StringOnlyModule())
                .waitForInitialRemoteData()
                .build();
        final Realm realm = Realm.getInstance(syncConfiguration);
        realm.executeTransaction(new Realm.Transaction() {
            @Override
            public void execute(Realm realm) {
                realm.createObject(StringOnly.class).setChars("1");
            }
        });

        final SyncSession session = SyncManager.getSession(syncConfiguration);
        session.uploadAllLocalChanges();

        user.logout();

        // add a commit while we're still offline
        realm.executeTransaction(new Realm.Transaction() {
            @Override
            public void execute(Realm realm) {
                realm.createObject(StringOnly.class).setChars("2");
            }
        });

        final CountDownLatch testCompleted = new CountDownLatch(1);

        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
        handlerThread.start();
        Looper looper = handlerThread.getLooper();
        Handler handler = new Handler(looper);
        handler.post(new Runnable() {
            @Override
            public void run() {
                // access the Realm from an different path on the device (using admin user), then monitor
                // when the offline commits get synchronized
                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);

                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
                        .modules(new StringOnlyModule())
                        .waitForInitialRemoteData()
                        .build();
                final Realm adminRealm = Realm.getInstance(adminConfig);

                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
                RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
                    @Override
                    public void onChange(RealmResults<StringOnly> stringOnlies) {
                        if (stringOnlies.size() == 2) {
                            Assert.assertEquals("1", stringOnlies.get(0).getChars());
                            Assert.assertEquals("2", stringOnlies.get(1).getChars());
                            adminRealm.close();
                            testCompleted.countDown();
                            handlerThread.quit();
                        }
                    }
                };
                all.addChangeListener(realmChangeListener);

                // login again to re-activate the user
                SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
                // this login will re-activate the logged out user, and resume all it's pending sessions
                // the OS will trigger bindSessionWithConfig with the new refresh_token, in order to obtain
                // a new access_token.
                SyncUser.login(credentials, Constants.AUTH_URL);
            }
        });

        TestHelper.awaitOrFail(testCompleted, 60);
        realm.close();
    }

