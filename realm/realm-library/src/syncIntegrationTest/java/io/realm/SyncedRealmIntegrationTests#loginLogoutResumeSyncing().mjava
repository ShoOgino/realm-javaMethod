    @Test
    @RunTestInLooperThread
    public void loginLogoutResumeSyncing() throws InterruptedException {
        String username = UUID.randomUUID().toString();
        String password = "password";
        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);

        SyncConfiguration config = user.createConfiguration(Constants.USER_REALM)
                .schema(StringOnly.class)
                .fullSynchronization()
                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                .build();

        Realm realm = Realm.getInstance(config);
        realm.beginTransaction();
        realm.createObject(StringOnly.class).setChars("Foo");
        realm.commitTransaction();
        SyncManager.getSession(config).uploadAllLocalChanges();
        user.logOut();
        realm.close();
        try {
            assertTrue(Realm.deleteRealm(config));
        } catch (IllegalStateException e) {
            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been
            // closed for now https://github.com/realm/realm-java/issues/5416
            if (e.getMessage().contains("It's not allowed to delete the file")) {
                // retry after 1 second
                SystemClock.sleep(1000);
                assertTrue(Realm.deleteRealm(config));
            }
        }

        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
        SyncConfiguration config2 = user.createConfiguration(Constants.USER_REALM)
                .fullSynchronization()
                .schema(StringOnly.class)
                .build();

        Realm realm2 = Realm.getInstance(config2);
        SyncManager.getSession(config2).downloadAllServerChanges();
        realm2.refresh();
        assertEquals(1, realm2.where(StringOnly.class).count());
        realm2.close();
        looperThread.testComplete();
    }

