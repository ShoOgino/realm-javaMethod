    // The pre-emptive token refresh subsystem should function, and properly refresh the access token.
    // WARNING: this test can fail if there's a difference between the server's and device's clock, causing the
    // refresh access token to be too far in time.
    @Test(timeout = 30000)
    @Ignore("Resolve https://github.com/realm/ros/issues/277")
    public void preemptiveTokenRefresh() throws NoSuchFieldException, IllegalAccessException, InterruptedException {
        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);

        // make the access tokens map accessible
        Field realmsField = SyncUser.class.getDeclaredField("realms");
        realmsField.setAccessible(true);
        @SuppressWarnings("unchecked") // using reflection
        Map<SyncConfiguration, Token> accessTokens = (Map<SyncConfiguration, Token>) realmsField.get(user);

        final SyncConfiguration syncConfiguration = configurationFactory
                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                .modules(new StringOnlyModule())
                .errorHandler(new SyncSession.ErrorHandler() {
                    @Override
                    public void onError(SyncSession session, ObjectServerError error) {
                        fail(error.getErrorMessage());
                    }
                })
                .build();
        Realm realm = Realm.getInstance(syncConfiguration);

        // create and wait for a transaction to be uploaded,
        // this guarantees that an accessToken is available
        realm.executeTransaction(new Realm.Transaction() {
            @Override
            public void execute(Realm realm) {
                realm.createObject(StringOnly.class).setChars("1");
            }
        });
        SyncSession session = SyncManager.getSession(syncConfiguration);
        session.uploadAllLocalChanges();

        assertFalse(accessTokens.isEmpty());
        Assert.assertEquals(1, accessTokens.size());
        Map.Entry<SyncConfiguration, Token> entry = accessTokens.entrySet().iterator().next();
        Assert.assertEquals(syncConfiguration, entry.getKey());

        final Token accessToken = entry.getValue();
        Assert.assertNotNull(accessToken);
        // getting refresh token delay
        Field refreshTokenTaskField = SyncSession.class.getDeclaredField("refreshTokenTask");
        refreshTokenTaskField.setAccessible(true);
        RealmAsyncTaskImpl task = (RealmAsyncTaskImpl) refreshTokenTaskField.get(session);
        Field pendingTaskField = RealmAsyncTaskImpl.class.getDeclaredField("pendingTask");
        pendingTaskField.setAccessible(true);
        ScheduledFuture<?> pendingTask = (ScheduledFuture<?>) pendingTaskField.get(task);
        long nextRefreshTokenRefreshQueryDelay = pendingTask.getDelay(TimeUnit.MILLISECONDS);

        // current configuration 'realm-java/tools/sync_test_server/configuration.yml'
        // is setting the access token to expire every 20 seconds 'access_token: 20'
        // we wait approximately actually 10 seconds since the SyncSession.REFRESH_MARGIN_DELAY is 10s
        SystemClock.sleep(nextRefreshTokenRefreshQueryDelay);

        // allow 3 seconds for the query to perform and complete
        SystemClock.sleep(TimeUnit.SECONDS.toMillis(3));

        Token newAccessToken = accessTokens.get(syncConfiguration);
        assertThat("new Token expires after the old one", newAccessToken.expiresMs(), greaterThan(accessToken.expiresMs()));
        assertNotEquals(accessToken, newAccessToken);

        // refresh_token identity is the same
        assertEquals(SyncTestUtils.getRefreshToken(user).identity(), newAccessToken.identity());
        assertEquals(accessToken.identity(), newAccessToken.identity());

        realm.close();
    }

