    @Test
    public void downloadProgressListener_indefinitely() throws InterruptedException {
        final AtomicInteger transferCompleted = new AtomicInteger(0);
        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
        final CountDownLatch startWorker = new CountDownLatch(1);
        final SyncUser userWithData = UserFactory.createUniqueUser(Constants.AUTH_URL);
        final SyncConfiguration userWithDataConfig = configFactory.createSyncConfigurationBuilder(userWithData, Constants.USER_REALM)
                .name("remote")
                .build();

        URI serverUrl = createRemoteData(userWithDataConfig);

        // Create worker thread that puts data into another Realm.
        // This is to avoid blocking one progress listener while waiting for another to complete.
        Thread worker = new Thread(new Runnable() {
            @Override
            public void run() {
                TestHelper.awaitOrFail(startWorker);
                createRemoteData(userWithDataConfig);
            }
        });
        worker.start();

        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString())
                .name("local")
                .build();
        Realm adminRealm = Realm.getInstance(adminConfig);
        SyncSession session = SyncManager.getSession(adminConfig);
        session.addDownloadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
            @Override
            public void onChange(Progress progress) {
                long objectCounts = getStoreTestDataSize(adminConfig);
                // The downloading progress listener could be triggered at the db version where only contains the meta
                // data. So we start checking from when the first 10 objects downloaded.
                RealmLog.warn(String.format(
                        Locale.ENGLISH,"downloadProgressListener_indefinitely download %d/%d objects count:%d",
                        progress.getTransferredBytes(), progress.getTransferableBytes(), objectCounts));
                if (objectCounts != 0 && progress.isTransferComplete()) {

                    switch (transferCompleted.incrementAndGet()) {
                        case 1: {
                            assertEquals(TEST_SIZE, objectCounts);
                            assertTransferComplete(progress, true);
                            startWorker.countDown();
                            break;
                        }
                        case 2: {
                            assertTransferComplete(progress, true);
                            assertEquals(TEST_SIZE * 2, objectCounts);
                            allChangesDownloaded.countDown();
                            break;
                        }
                        default:
                            fail("Transfer complete called too many times:" + transferCompleted.get());
                    }
                }
            }
        });
        TestHelper.awaitOrFail(allChangesDownloaded);
        adminRealm.close();
        // worker thread will hang if logout happens before listener triggered.
        worker.join();
        userWithData.logout();
        adminUser.logout();
    }

