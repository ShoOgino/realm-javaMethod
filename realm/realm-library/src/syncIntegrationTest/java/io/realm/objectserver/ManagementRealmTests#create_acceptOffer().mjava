    @Ignore("Failing due to terminate called after throwing an instance of 'realm::MultipleSyncAgents'. Will be fixed when upgrading to Sync 1.10")
    @Test
    @RunTestInLooperThread
    public void create_acceptOffer() {
        SyncUser user1 = UserFactory.createUniqueUser(Constants.AUTH_URL);
        final SyncUser user2 = UserFactory.createUniqueUser(Constants.AUTH_URL);

        // 1. User1 creates Realm that user2 does not have access
        final String user1RealmUrl = "realm://127.0.0.1:9080/" + user1.getIdentity() + "/permission-offer-test";
        SyncConfiguration config1 = new SyncConfiguration.Builder(user1, user1RealmUrl).
                errorHandler(new SyncSession.ErrorHandler() {
                    @Override
                    public void onError(SyncSession session, ObjectServerError error) {
                        fail("Realm 1 unexpected error: " + error);
                    }
                })
                .build();
        final Realm realm1 = Realm.getInstance(config1);
        looperThread.addTestRealm(realm1);
        realm1.executeTransactionAsync(new Realm.Transaction() {
            @Override
            public void execute(Realm realm) {
                realm.createObject(Dog.class);
            }
        });

        // 2. Create configuration for User2's Realm.
        final SyncConfiguration config2 = new SyncConfiguration.Builder(user2, user1RealmUrl).build();

        // 3. Create PermissionOffer
        final AtomicReference<String> offerId = new AtomicReference<String>(null);
        final Realm user1ManagementRealm = user1.getManagementRealm();
        looperThread.addTestRealm(user1ManagementRealm);
        user1ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
            @Override
            public void execute(Realm realm) {
                PermissionOffer offer = new PermissionOffer(user1RealmUrl, AccessLevel.WRITE, null);
                offerId.set(offer.getId());
                realm.copyToRealm(offer);
            }
        }, new Realm.Transaction.OnSuccess() {
            @Override
            public void onSuccess() {
                // 4. Wait for offer to get an token
                RealmLog.error("OfferID: " + offerId.get());
                RealmResults<PermissionOffer> offers = user1ManagementRealm.where(PermissionOffer.class)
                        .equalTo("id", offerId.get())
                        .findAllAsync();
                looperThread.keepStrongReference(offers);
                offers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
                    @Override
                    public void onChange(RealmResults<PermissionOffer> offers) {
                        final PermissionOffer offer = offers.first(null);
                        if (offer != null && offer.isOfferCreated() && offer.getToken() != null) {
                            // 5. User2 uses the token to accept the offer
                            final String offerToken = offer.getToken();
                            final AtomicReference<String> offerResponseId = new AtomicReference<String>();
                            final Realm user2ManagementRealm = user2.getManagementRealm();
                            looperThread.addTestRealm(user2ManagementRealm);
                            user2ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
                                @Override
                                public void execute(Realm realm) {
                                    PermissionOfferResponse offerResponse = new PermissionOfferResponse(offerToken);
                                    offerResponseId.set(offerResponse.getId());
                                    realm.copyToRealm(offerResponse);
                                }
                            }, new Realm.Transaction.OnSuccess() {
                                @Override
                                public void onSuccess() {
                                    // 6. Wait for the offer response to be accepted
                                    RealmResults<PermissionOfferResponse> responses = user2ManagementRealm.where(PermissionOfferResponse.class)
                                            .equalTo("id", offerResponseId.get())
                                            .findAllAsync();
                                    looperThread.keepStrongReference(responses);
                                    responses.addChangeListener(new RealmChangeListener<RealmResults<PermissionOfferResponse>>() {
                                        @Override
                                        public void onChange(RealmResults<PermissionOfferResponse> responses) {
                                            PermissionOfferResponse response = responses.first(null);
                                            if (response != null && response.isSuccessful() && response.getToken().equals(offerToken)) {
                                                // 7. Response accepted. It should now be possible for user2 to access user1's Realm
                                                Realm realm = Realm.getInstance(config2);
                                                looperThread.addTestRealm(realm);
                                                RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
                                                looperThread.keepStrongReference(dogs);
                                                dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                                                    @Override
                                                    public void onChange(RealmResults<Dog> element) {
                                                        assertEquals(1, element.size());
                                                        looperThread.testComplete();
                                                    }
                                                });
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    }
                });
            }
        });
    }

