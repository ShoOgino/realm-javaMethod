    // UC:
    //   1- insert 10 objects
    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
    //   4- the queries will complete with the same version as the caller thread
    //   5- using a background thread update the Realm
    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
    //   7- callbacks are notified with the latest results (called twice overall)
    @Test
    @RunTestInLooperThread
    public void findAllAsync_batchUpdate() throws Throwable {
        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
        final Realm realm = looperThread.realm;
        populateTestRealm(realm, 10);

        // 1. Configure Handler interceptor
        Handler handler = new HandlerProxy(realm.handlerController) {
            @Override
            public boolean onInterceptOutMessage(int what) {
                return false;
            }

            @Override
            public boolean onInterceptInMessage(int what) {
                int intercepts = numberOfIntercept.getAndIncrement();
                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
                    // 4. The first time the async queries complete we start an update from
                    // another background thread. This will cause queries to rerun when the
                    // background thread notifies this thread.
                    new RealmBackgroundTask(looperThread.realmConfiguration) {
                        @Override
                        public void doInBackground(Realm realm) {
                            realm.beginTransaction();
                            realm.where(AllTypes.class)
                                    .equalTo(AllTypes.FIELD_LONG, 4)
                                    .findFirst()
                                    .setColumnString("modified");
                            realm.createObject(AllTypes.class);
                            realm.createObject(AllTypes.class);
                            realm.commitTransaction();
                        }
                    }.awaitOrFail();
                }
                return false;
            }
        };
        realm.setHandler(handler);

        // 2. Create 2 async queries and check they are not loaded
        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class).findAllAsync();
        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class).between("columnLong", 0, 4).findAllAsync();

        assertFalse(realmResults1.isLoaded());
        assertFalse(realmResults2.isLoaded());
        assertEquals(0, realmResults1.size());
        assertEquals(0, realmResults2.size());

        // 3. Change listeners will be called twice. Once when the first query completely and then
        // when the background thread has completed, notifying this thread to rerun and then receive
        // the updated results.
        final Runnable signalCallbackDone = new Runnable() {
            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
            @Override
            public void run() {
                if (signalCallbackFinished.decrementAndGet() == 0) {
                    assertEquals(4, numberOfIntercept.get());
                    assertEquals(2, numberOfNotificationsQuery1.get());
                    assertEquals(2, numberOfNotificationsQuery2.get());
                    looperThread.testComplete();
                }
            }
        };

        realmResults1.addChangeListener(new RealmChangeListener() {
            @Override
            public void onChange() {
                switch (numberOfNotificationsQuery1.incrementAndGet()) {
                    case 1: // first callback invocation
                        assertTrue(realmResults1.isLoaded());
                        assertEquals(10, realmResults1.size());
                        assertEquals("test data 4", realmResults1.get(4).getColumnString());
                        break;

                    case 2: // second callback
                        assertTrue(realmResults1.isLoaded());
                        assertEquals(12, realmResults1.size());
                        assertEquals("modified", realmResults1.get(4).getColumnString());
                        signalCallbackDone.run();
                        break;
                }
            }
        });


        realmResults2.addChangeListener(new RealmChangeListener() {
            @Override
            public void onChange() {
                switch (numberOfNotificationsQuery2.incrementAndGet()) {
                    case 1: // first callback invocation
                        assertTrue(realmResults2.isLoaded());
                        assertEquals(5, realmResults2.size());
                        assertEquals("test data 4", realmResults2.get(4).getColumnString());
                        break;

                    case 2: // second callback
                        assertTrue(realmResults2.isLoaded());
                        assertEquals(7, realmResults2.size());
                        assertEquals("modified", realmResults2.get(4).getColumnString());
                        signalCallbackDone.run();
                        break;
                }
            }
        });
    }

