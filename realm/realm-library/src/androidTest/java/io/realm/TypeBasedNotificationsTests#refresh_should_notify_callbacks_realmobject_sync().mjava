    // ****************************************************************************************** //
    // UC 5.
    // Callback should be notified if we call refresh (even without getting the REALM_CHANGE yet)
    // ***************************************************************************************** //
    @Test
    @RunTestInLooperThread
    public void refresh_should_notify_callbacks_realmobject_sync() {
        final Realm realm = looperThread.realm;
        // Swallow all REALM_CHANGED events to test the behaviour of refresh
        final Handler handler = new HandlerProxy(realm.handlerController) {
            @Override
            public boolean onInterceptInMessage(int what) {
                switch (what) {
                    case HandlerController.REALM_CHANGED: {
                        return true;
                    }
                }
                return false;
            }
        };
        realm.setHandler(handler);

        realm.beginTransaction();
        realm.createObject(Dog.class);
        realm.commitTransaction();

        final Dog dog = realm.where(Dog.class).findFirst();
        assertNull(dog.getName());

        dog.addChangeListener(new RealmChangeListener() {
            @Override
            public void onChange() {
                assertEquals("Akamaru", dog.getName());
                looperThread.testComplete();
            }
        });

        Thread thread = new Thread() {
            @Override
            public void run() {
                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
                bgRealm.beginTransaction();
                bgRealm.where(Dog.class).findFirst().setName("Akamaru");
                bgRealm.commitTransaction();
                bgRealm.close();
            }
        };
        thread.start();

        try {
            thread.join();
        } catch (InterruptedException e) {
            fail(e.getMessage());
        }

        realm.refresh();
    }

