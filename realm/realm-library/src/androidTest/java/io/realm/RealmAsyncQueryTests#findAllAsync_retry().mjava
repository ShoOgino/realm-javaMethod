    // UC:
    //   1- Inserts 10 objects.
    //   2- Starts an async query to find object [0-4].
    //   3- Asserts current RealmResults is empty (Worker Thread didn't complete).
    //   4- When the worker thread completes, advances the Realm.
    //   5- The caller thread is ahead of the result provided by the worker thread.
    //   6- Retries automatically the async query.
    //   7- The returned RealmResults is now in the same version as the caller thread.
    //   8- The notification should be called once (when we retry automatically we shouldn't
    //      notify the user).
    @Test
    @RunTestInLooperThread
    public void findAllAsync_retry() throws Throwable {
        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
        final AtomicInteger numberOfInvocation = new AtomicInteger(0);
        final Realm realm = looperThread.realm;

        // 1. Populates initial data.
        realm.setAutoRefresh(false);
        populateTestRealm(realm, 10);
        realm.setAutoRefresh(true);

        // 2. Configures handler interceptor.
        final Handler handler = new HandlerProxy(realm.handlerController) {
            @Override
            public boolean onInterceptInMessage(int what) {
                // Intercepts in order: [QueryComplete, RealmChanged, QueryUpdated].
                int intercepts = numberOfIntercept.incrementAndGet();
                switch (what) {
                    // 5. Intercepts all messages from other threads. On the first complete, we advance the tread
                    // which will cause the async query to rerun instead of triggering the change listener.
                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
                        if (intercepts == 1) {
                            // We advance the Realm so we can simulate a retry.
                            realm.beginTransaction();
                            realm.delete(AllTypes.class);
                            realm.commitTransaction();
                        }
                }
                return false;
            }
        };
        realm.setHandler(handler);

        // 3. Creates a async query.
        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                .between("columnLong", 0, 4)
                .findAllAsync();

        // 4. Ensures that query isn't loaded yet.
        assertFalse(realmResults.isLoaded());
        assertEquals(0, realmResults.size());

        // 6. Callback triggered after retry has completed.
        looperThread.keepStrongReference.add(realmResults);
        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
            @Override
            public void onChange(RealmResults<AllTypes> object) {
                assertEquals(3, numberOfIntercept.get());
                assertEquals(1, numberOfInvocation.incrementAndGet());
                assertTrue(realmResults.isLoaded());
                assertEquals(0, realmResults.size());
                looperThread.testComplete();
            }
        });
    }

