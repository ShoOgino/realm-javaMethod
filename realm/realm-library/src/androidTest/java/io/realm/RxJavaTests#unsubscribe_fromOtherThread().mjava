    @Test
    @UiThreadTest
    public void unsubscribe_fromOtherThread() {
        final CountDownLatch unsubscribeCompleted = new CountDownLatch(1);
        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
        final Disposable subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
            @Override
            public void accept(Realm rxRealm) throws Exception {
                assertTrue(rxRealm == realm);
                subscribedNotified.set(true);
            }
        });
        assertTrue(subscribedNotified.get());
        assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    subscription.dispose();
                    fail();
                } catch (IllegalStateException ignored) {
                } finally {
                    unsubscribeCompleted.countDown();
                }
            }
        }).start();
        TestHelper.awaitOrFail(unsubscribeCompleted);
        assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
        // We cannot call subscription.dispose() again, so manually close the extra Realm instance opened by
        // the Observable.
        realm.close();
    }

