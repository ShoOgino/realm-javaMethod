    // UC:
    //   1- insert 10 objects
    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
    //   4- start a third thread to insert 2 more elements
    //   5- the third thread signal a REALM_CHANGE that should update all async queries
    //   6- when the results from step [2] completes they should be ignored, since a pending
    //      update (using the latest realm) for all async queries is in progress
    //   7- onChange notification will be triggered once
    @Test
    @RunTestInLooperThread
    public void findAllAsync_callerThreadBehind() throws Throwable {
        final AtomicInteger numberOfCompletedAsyncQuery = new AtomicInteger(0);
        final AtomicInteger numberOfInterceptedChangeMessage = new AtomicInteger(0);
        final AtomicInteger maxNumberOfNotificationsQuery1 = new AtomicInteger(1);
        final AtomicInteger maxNumberOfNotificationsQuery2 = new AtomicInteger(1);
        final Realm realm = looperThread.realm;
        populateTestRealm(realm, 10);

        // Configure Handler Interceptor
        final Handler handler = new HandlerProxy(realm.handlerController) {
            @Override
            public boolean onInterceptInMessage(int what) {
                switch (what) {
                    case HandlerControllerConstants.REALM_CHANGED: {
                        // should only intercept the first REALM_CHANGED coming from the
                        // background update thread

                        // swallow this message, so the caller thread
                        // remain behind the worker thread. This has as
                        // a consequence to ignore the delivered result & wait for the
                        // upcoming REALM_CHANGED to batch update all async queries
                        return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
                    }
                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                        if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
                            // both queries have completed now (& their results should be ignored)
                            // now send the REALM_CHANGED event that should batch update all queries
                            sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
                        }
                    }
                }
                return false;
            }
        };
        realm.setHandler(handler);
        Realm.asyncTaskExecutor.pause();

        // Create async queries and check they haven't completed
        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
                .findAllAsync();
        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
                .between("columnLong", 0, 4).findAllAsync();

        assertFalse(realmResults1.isLoaded());
        assertFalse(realmResults2.isLoaded());
        assertEquals(0, realmResults1.size());
        assertEquals(0, realmResults2.size());

        // advance the Realm from a background thread
        new RealmBackgroundTask(looperThread.realmConfiguration) {
            @Override
            public void doInBackground(Realm realm) {
                realm.beginTransaction();
                realm.where(AllTypes.class).equalTo("columnLong", 4).findFirst().setColumnString("modified");
                realm.createObject(AllTypes.class);
                realm.createObject(AllTypes.class);
                realm.commitTransaction();
            }
        }.awaitOrFail();
        Realm.asyncTaskExecutor.resume();

        // Setup change listeners
        final Runnable signalCallbackDone = new Runnable() {
            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
            @Override
            public void run() {
                if (signalCallbackFinished.decrementAndGet() == 0) {
                    assertEquals(0, maxNumberOfNotificationsQuery1.get());
                    assertEquals(0, maxNumberOfNotificationsQuery2.get());
                    looperThread.testComplete();
                }
            }
        };

        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
            @Override
            public void onChange(RealmResults<AllTypes> object) {
                assertTrue(maxNumberOfNotificationsQuery1.getAndDecrement() > 0);
                assertTrue(realmResults1.isLoaded());
                assertEquals(12, realmResults1.size());
                assertEquals("modified", realmResults1.get(4).getColumnString());
                signalCallbackDone.run();
            }
        });

        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
            @Override
            public void onChange(RealmResults<AllTypes> object) {
                assertTrue(maxNumberOfNotificationsQuery2.getAndDecrement() > 0);
                assertTrue(realmResults2.isLoaded());
                assertEquals(7, realmResults2.size());// the 2 add rows has columnLong == 0
                assertEquals("modified", realmResults2.get(4).getColumnString());
                signalCallbackDone.run();
            }
        });
    }

