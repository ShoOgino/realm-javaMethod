    // UC:
    //   1- Inserts 10 objects.
    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
    //   4- Starts a third thread to insert 2 more elements.
    //   5- The third thread signal a REALM_CHANGE that should update all async queries.
    //   6- When the results from step [2] completes they should be ignored, since a pending
    //      update (using the latest realm) for all async queries is in progress.
    //   7- onChange notification will be triggered once.
    @Test
    @RunTestInLooperThread
    public void findAllAsync_callerThreadBehind() throws Throwable {
        final AtomicInteger numberOfCompletedAsyncQuery = new AtomicInteger(0);
        final AtomicInteger numberOfInterceptedChangeMessage = new AtomicInteger(0);
        final AtomicInteger maxNumberOfNotificationsQuery1 = new AtomicInteger(1);
        final AtomicInteger maxNumberOfNotificationsQuery2 = new AtomicInteger(1);
        final Realm realm = looperThread.realm;
        populateTestRealm(realm, 10);

        // Configures Handler Interceptor.
        final Handler handler = new HandlerProxy(realm.handlerController) {
            @Override
            public boolean onInterceptInMessage(int what) {
                switch (what) {
                    case HandlerControllerConstants.REALM_CHANGED: {
                        // Should only intercept the first REALM_CHANGED coming from the
                        // background update thread.

                        // Swallows this message, so the caller thread
                        // remains behind the worker thread. This has as
                        // a consequence to ignore the delivered result & waits for the
                        // upcoming REALM_CHANGED to batch update all async queries.
                        return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
                    }
                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                        if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
                            // Both queries have completed now (& their results should be ignored)
                            // now sends the REALM_CHANGED event that should batch update all queries.
                            sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
                        }
                    }
                }
                return false;
            }
        };
        realm.setHandler(handler);
        Realm.asyncTaskExecutor.pause();

        // Creates async queries and checks they haven't completed.
        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
                .findAllAsync();
        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
                .between("columnLong", 0, 4).findAllAsync();

        assertFalse(realmResults1.isLoaded());
        assertFalse(realmResults2.isLoaded());
        assertEquals(0, realmResults1.size());
        assertEquals(0, realmResults2.size());

        // Advances the Realm from a background thread.
        new RealmBackgroundTask(looperThread.realmConfiguration) {
            @Override
            public void doInBackground(Realm realm) {
                realm.beginTransaction();
                realm.where(AllTypes.class).equalTo("columnLong", 4).findFirst().setColumnString("modified");
                realm.createObject(AllTypes.class);
                realm.createObject(AllTypes.class);
                realm.commitTransaction();
            }
        }.awaitOrFail();
        Realm.asyncTaskExecutor.resume();

        // Setups change listeners.
        final Runnable signalCallbackDone = new Runnable() {
            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
            @Override
            public void run() {
                if (signalCallbackFinished.decrementAndGet() == 0) {
                    assertEquals(0, maxNumberOfNotificationsQuery1.get());
                    assertEquals(0, maxNumberOfNotificationsQuery2.get());
                    looperThread.testComplete();
                }
            }
        };

        looperThread.keepStrongReference.add(realmResults1);
        looperThread.keepStrongReference.add(realmResults2);

        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
            @Override
            public void onChange(RealmResults<AllTypes> object) {
                assertTrue(maxNumberOfNotificationsQuery1.getAndDecrement() > 0);
                assertTrue(realmResults1.isLoaded());
                assertEquals(12, realmResults1.size());
                assertEquals("modified", realmResults1.get(4).getColumnString());
                signalCallbackDone.run();
            }
        });

        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
            @Override
            public void onChange(RealmResults<AllTypes> object) {
                assertTrue(maxNumberOfNotificationsQuery2.getAndDecrement() > 0);
                assertTrue(realmResults2.isLoaded());
                assertEquals(7, realmResults2.size());// the 2 add rows has columnLong == 0
                assertEquals("modified", realmResults2.get(4).getColumnString());
                signalCallbackDone.run();
            }
        });
    }

