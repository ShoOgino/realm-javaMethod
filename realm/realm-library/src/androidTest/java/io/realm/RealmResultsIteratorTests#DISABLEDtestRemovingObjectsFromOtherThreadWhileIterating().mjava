    // TODO: Should we reenable this test?
    // Using size() as heuristic for concurrent modifications is dangerous as we might skip
    // elements.
    // TODO Possible bug: Why does this interfere with reference counting check. They are separate Realm files.
    // TODO Possible bug: Why is realm.refresh() needed?
    public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws InterruptedException, ExecutionException {

        // Prefill
        final RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "test");
        Realm realm = Realm.getInstance(realmConfig);
        realm.beginTransaction();
        realm.delete(AllTypes.class);
        AllTypes o1 = realm.createObject(AllTypes.class);
        o1.setColumnLong(1);
        AllTypes o2 = realm.createObject(AllTypes.class);
        o2.setColumnLong(2);
        realm.commitTransaction();

        // Iterate past 1st item
        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
        Iterator<AllTypes> it = result.iterator();
        it.next();

        // Delete first item and insert new. Meaning Item 2 gets Item 1s place, and is skipped
        // in iterator when calling next().
        Callable<Boolean> backgroundWorker = new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                Realm backgroundRealm = Realm.getInstance(realmConfig);
                backgroundRealm.beginTransaction();
                RealmResults<AllTypes> backgroundResult = backgroundRealm.allObjects(AllTypes.class);
                if (backgroundResult.size() != 2) {
                    backgroundRealm.close();
                    return false;
                }
                backgroundResult.sort("columnLong", Sort.ASCENDING);
                backgroundResult.remove(0);
                AllTypes o3 = backgroundRealm.createObject(AllTypes.class);
                o3.setColumnLong(3);
                backgroundRealm.commitTransaction();
                int size = backgroundResult.size();
                backgroundRealm.close();
                if (size != 2) {
                    return false;
                } else {
                    return true;
                }
            }
        };

        // Wait for background thread to finish
        ExecutorService executorService = Executors.newFixedThreadPool(1);
        Future<Boolean> backgroundResult = executorService.submit(backgroundWorker);
        assertTrue(backgroundResult.get());
        realm.refresh(); // This shouldn't be needed, but is currently.

        // Next item would now be o3.
        try {
            AllTypes o3 = it.next();
            assertEquals(3, o3.getColumnLong());
            fail("Failed to detect the list was modified, but retained it's size while iterating");
        } catch (ConcurrentModificationException ignored) {
            return;
        } finally {
            realm.close();
        }
    }

