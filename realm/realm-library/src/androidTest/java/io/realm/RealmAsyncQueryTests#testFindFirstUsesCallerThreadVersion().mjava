    // Makes sure we don't get the run into the IllegalStateException.
    // (Caller thread behind the worker thread)
    // Scenario:
    // - Caller thread is in version 1, starts an asyncFindFirst.
    // - Another thread advances the Realm, now the latest version = 2.
    // - The worker thread should query against version 1 not version 2.
    // Otherwise the caller thread wouldn't be able to import the result.
    // - The notification mechanism will guarantee that the REALM_CHANGE triggered by
    // the background thread, will update the caller thread (advancing it to version 2).
    @Test
    @RunTestInLooperThread
    public void testFindFirstUsesCallerThreadVersion() throws Throwable {
        final CountDownLatch signalClosedRealm = new CountDownLatch(1);

        populateTestRealm(looperThread.realm, 10);
        Realm.asyncTaskExecutor.pause();

        final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
        looperThread.keepStrongReference.add(firstAsync);
        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
            @Override
            public void onChange(AllTypes object) {
                assertNotNull(firstAsync);
                assertEquals("test data 0", firstAsync.getColumnString());
                looperThread.testComplete(signalClosedRealm);
            }
        });

        // Advances the background Realm.
        new Thread() {
            @Override
            public void run() {
                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
                // Advances the Realm without generating notifications.
                bgRealm.sharedRealm.beginTransaction();
                bgRealm.sharedRealm.commitTransaction();
                Realm.asyncTaskExecutor.resume();
                bgRealm.close();
                signalClosedRealm.countDown();
            }
        }.start();
    }

