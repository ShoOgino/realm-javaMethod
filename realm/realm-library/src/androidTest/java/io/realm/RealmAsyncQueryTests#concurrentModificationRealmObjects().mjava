    // handlerController#realmObjects is accessed from different threads
    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
    @Test
    @UiThreadTest
    public void concurrentModificationRealmObjects() {
        RealmConfiguration config  = configFactory.createConfiguration();
        final Realm realm = Realm.getInstance(config);
        Dog dog1 = new Dog();
        dog1.setName("Dog 1");

        Dog dog2 = new Dog();
        dog2.setName("Dog 2");

        realm.beginTransaction();
        dog1 = realm.copyToRealm(dog1);
        dog2 = realm.copyToRealm(dog2);
        realm.commitTransaction();

        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);

        realm.handlerController.realmObjects.put(weakReference1, Boolean.TRUE);

        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, Object>> iterator = realm.handlerController.realmObjects.entrySet().iterator();
        AtomicBoolean fireOnce = new AtomicBoolean(true);
        while (iterator.hasNext()) {
            Dog next = (Dog) iterator.next().getKey().get();
            // add a new Dog from a background thread
            if (fireOnce.compareAndSet(true, false)) {
                new Thread() {
                    @Override
                    public void run() {
                        realm.handlerController.realmObjects.put(weakReference2, Boolean.TRUE);
                        dogAddFromBg.countDown();
                    }
                }.start();
                TestHelper.awaitOrFail(dogAddFromBg);
            }
            assertEquals("Dog 1", next.getName());
            assertFalse(iterator.hasNext());
        }

        realm.close();
    }

