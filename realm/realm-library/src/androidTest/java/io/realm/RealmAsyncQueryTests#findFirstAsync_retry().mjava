    // similar UC as #testFindAllAsyncRetry using 'findFirst'
    // UC:
    //   1- insert 10 objects
    //   2- start an async query to find object [0-4]
    //   3- assert current RealmResults is empty (Worker Thread didn't complete)
    //   4- when the worker thread complete, advance the Realm
    //   5- the caller thread is ahead of the result provided by the worker thread
    //   6- retry automatically the async query
    //   7- the returned RealmResults is now in the same version as the caller thread
    //   8- the notification should be called once (when we retry automatically we shouldn't
    //      notify the user).
    @Test
    @RunTestInLooperThread
    public void findFirstAsync_retry() throws Throwable {
        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
        final Realm realm = looperThread.realm;
        populateTestRealm(realm, 10);

        // Configure interceptor handler
        final Handler handler = new HandlerProxy(realm.handlerController) {
            @Override
            public boolean onInterceptInMessage(int what) {
                int intercepts = numberOfIntercept.incrementAndGet();
                switch (what) {
                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
                        if (intercepts == 1) {
                            // we advance the Realm so we can simulate a retry
                            realm.beginTransaction();
                            realm.delete(AllTypes.class);
                            AllTypes object = realm.createObject(AllTypes.class);
                            object.setColumnString("The Endless River");
                            object.setColumnLong(5);
                            realm.commitTransaction();
                        }
                    }
                }
                return false;
            }
        };
        //realm.setHandler(handler);

        // Create a async query and verify it is not still loaded.
        final AllTypes realmResults = realm.where(AllTypes.class)
                .between("columnLong", 4, 6)
                .findFirstAsync();

        assertFalse(realmResults.isLoaded());

        try {
            realmResults.getColumnString();
            fail("Accessing property on an empty row");
        } catch (IllegalStateException ignored) {
        }

        // Add change listener that should only be called once after the retry completed.
        looperThread.keepStrongReference.add(realmResults);
        realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
            @Override
            public void onChange(AllTypes object) {
                assertEquals(3, numberOfIntercept.get());
                assertTrue(realmResults.isLoaded());
                assertEquals(5, realmResults.getColumnLong());
                assertEquals("The Endless River", realmResults.getColumnString());
                looperThread.testComplete();
            }
        });
    }

