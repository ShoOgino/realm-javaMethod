    // Calling methods from the wrong thread should fail
    private boolean methodWrongThread(final Method method) throws InterruptedException, ExecutionException {
        testRealm.beginTransaction();
        testRealm.clear(AllTypes.class);
        testRealm.clear(Dog.class);
        final RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
        Dog dog = testRealm.createObject(Dog.class);
        list.add(dog);
        testRealm.commitTransaction();

        testRealm.beginTransaction(); // Make sure that a valid transaction has begun on the correct thread
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                try {
                    switch (method) {
                        case METHOD_ADD:
                            list.add(new Dog());
                            break;
                        case METHOD_ADD_AT:
                            list.add(1, new Dog());
                            break;
                        case METHOD_CLEAR:
                            list.clear();
                            break;
                        case METHOD_MOVE:
                            list.add(new Dog());
                            list.move(0, 1);
                            break;
                        case METHOD_REMOVE:
                            list.remove(0);
                            break;
                        case METHOD_SET:
                            list.set(0, new Dog());
                            break;
                    }
                    return false;
                } catch (IllegalStateException ignored) {
                    return true;
                }
            }
        });

        boolean result = future.get();
        testRealm.cancelTransaction();
        return result;
    }

