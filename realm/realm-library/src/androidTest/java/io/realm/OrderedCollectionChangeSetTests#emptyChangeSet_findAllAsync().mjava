    // The change set should empty when the async query returns at the first time.
    @Test
    @RunTestInLooperThread
    public void emptyChangeSet_findAllAsync(){
        if (type == ObservablesType.REALM_LIST) {
            looperThread.testComplete();
            return;
        }
        Realm realm = looperThread.realm;
        populateData(realm, 10);
        final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
        results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
            @Override
            public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
                assertSame(collection, results);
                assertEquals(9, collection.size());
                assertNull(changeSet);
                looperThread.testComplete();
            }
        });

        final CountDownLatch bgDeletionLatch = new CountDownLatch(1);
        // beginTransaction() will make the async query return immediately. So we have to create an object in another
        // thread. Also, the latch has to be counted down after transaction committed so the async query results can
        // contain the modification in the background transaction.
        new Thread(new Runnable() {
            @Override
            public void run() {
                Realm realm = Realm.getInstance(looperThread.realmConfiguration)      ;
                realm.beginTransaction();
                realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 0).findFirst().deleteFromRealm();
                realm.commitTransaction();
                realm.close();
                bgDeletionLatch.countDown();
            }
        }).start();
        TestHelper.awaitOrFail(bgDeletionLatch);
    }

