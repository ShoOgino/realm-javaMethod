    // Tests all methods that mutate data throw correctly if not inside an transaction.
    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level.
    @Test
    public void mutableMethodsOutsideTransactions() {
        for (CollectionMutatorMethod method : CollectionMutatorMethod.values()) {

            // Defines expected exception.
            Class<? extends Throwable> expected = IllegalStateException.class;
            if (collectionClass == ManagedCollection.REALMRESULTS) {
                switch (method) {
                    case ADD_OBJECT:
                    case ADD_ALL_OBJECTS:
                    case CLEAR:
                    case REMOVE_OBJECT:
                    case REMOVE_ALL:
                    case RETAIN_ALL:
                        expected = UnsupportedOperationException.class;
                }
            }

            try {
                switch (method) {
                    case DELETE_ALL: collection.deleteAllFromRealm(); break;
                    case ADD_OBJECT: collection.add(new AllJavaTypes());
                    case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes())); break;
                    case CLEAR: collection.clear(); break;
                    case REMOVE_OBJECT: collection.remove(new AllJavaTypes()); break;
                    case REMOVE_ALL: collection.removeAll(Collections.singletonList(new AllJavaTypes())); break;
                    case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllJavaTypes())); break;
                }
                fail("Unknown method or it failed to throw: " + method);
            } catch (Throwable t) {
                if (!t.getClass().equals(expected)) {
                    fail(method + " didn't throw the expected exception. Was: " + t + ", expected: " + expected);
                }
            }
        }
    }

