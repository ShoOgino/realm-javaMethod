    /**
     * This is called from the Object Store (through JNI) to request an {@code access_token} for
     * the session specified by sessionPath.
     *
     * This will also schedule a timer to proactively refresh the {@code access_token} regularly, before
     * the {@code access_token} expires.
     *
     * @throws IllegalStateException if the wrapped Java session is not found.
     * @param sessionPath The path to the previously Java wraped session.
     * @return a valid cached {@code access_token} if available or null.
     */
    @SuppressWarnings("unused")
//    private synchronized static String bindSessionWithConfig(String sessionPath, String refreshToken) {
//        final SyncSession syncSession = sessions.get(sessionPath);
//        if (syncSession == null) {
//            RealmLog.error("Matching Java SyncSession could not be found for: " + sessionPath);
//        } else {
//            try {
//                return syncSession.getAccessToken(authServer, refreshToken);
//            } catch (Exception exception) {
//                RealmLog.error(exception);
//            }
//        }
//        return null;
//    }

    /**
     * Realm will automatically detect when a device gets connectivity after being offline and
     * resume syncing.
     * <p>
     * However, as some of these checks are performed using incremental backoff, this will in some
     * cases not happen immediately.
     * <p>
     * In those cases it can be beneficial to call this method manually, which will force all
     * sessions to attempt to reconnect immediately and reset any timers they are using for
     * incremental backoff.
     */
    public static void refreshConnections() {
        notifyNetworkIsBack();
    }

