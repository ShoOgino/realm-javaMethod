    // Authenticate by getting access tokens for the specific Realm
    private synchronized void refreshAccessToken(final RealmObjectServer authServer) {
        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
        clearScheduledAccessTokenRefresh();
        final String taskName = "Session[" + configuration.getPath() + "][RefreshAccessToken]";
        refreshTokenNetworkRequest = new ResetableRealmAsyncTask(new ExponentialBackoffTask<AuthenticateResponse>() {
            @Override
            protected AuthenticateResponse execute() {
                if (!isClosed && !Thread.currentThread().isInterrupted()) {
                    return authServer.refreshUser(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());
                }
                return null;
            }

            @Override
            protected void onSuccess(AuthenticateResponse response) {
                synchronized (SyncSession.this) {
                    if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenNetworkRequest.isCancelled()) {
                        RealmLog.debug("Session[%s]: Access Token refreshed successfully.", configuration.getPath());

                        SyncWorker syncWorker = response.getSyncWorker();
                        if (syncWorker != null) {
                            nativeSetUrlPrefix(configuration.getPath(), syncWorker.path());
                        }

                        URI realmUrl = configuration.getServerUrl();
                        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {
                            // replace the user old access_token
                            getUser().addRealm(configuration, response.getAccessToken());
                            // schedule the next refresh
                            scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
                        }
                    }
                    refreshTokenNetworkRequest = null;
                }
            }

            @Override
            protected void onError(AuthenticateResponse response) {
                if (!isClosed && !Thread.currentThread().isInterrupted()) {
                    onGoingAccessTokenQuery.set(false);
                    RealmLog.debug("Session[%s]: Unrecoverable error, while refreshing the access Token. Reschedule will not happen. %s", configuration.getPath(), response.getError());
                }
                refreshTokenNetworkRequest = null;
            }

            @Override
            protected String getName() {
                return taskName;
            }
        }, SyncManager.NETWORK_POOL_EXECUTOR);
    }

