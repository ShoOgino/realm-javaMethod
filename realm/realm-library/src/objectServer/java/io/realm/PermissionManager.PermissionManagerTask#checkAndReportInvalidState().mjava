        /**
         * Checks if we are in a state where we are not allowed to continue executing.
         * If an invalid state is encountered, it will be reported to the error callback.
         *
         * This method will return {@code true} if an invalid state was encountered, {@code false}
         * if it looks ok to continue.

         * @return {@code true} if in a invalid state, {@code false} if in a valid one.
         */
        protected final boolean checkAndReportInvalidState() {
            if (isCancelled()) {
                permissionManager.activeTasks.remove(this);
                return true;
            }
            // Closed check need to work around thread confinement
            if (permissionManager.closed) {
                ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN,
                        new IllegalStateException("PermissionManager has been closed"));
                notifyCallbackWithError(error); // This will remove the task from the task list
                return true;
            }
            if (permissionManager.clientReset) {
                ObjectServerError error = new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET);
                notifyCallbackWithError(error);
                return true;
            }

            // We are juggling two different Realms. If only one fail, expose that error directly.
            // Otherwise try to sensible join the two error messages before returning it to the user.
            // TODO: Should we expose the underlying Realm errors directly? What else would make sense?
            boolean managementErrorHappened;
            boolean permissionErrorHappened;
            boolean defaultPermissionErrorHappened;
            ObjectServerError managementError;
            ObjectServerError permissionError;
            ObjectServerError defaultPermissionError;
            synchronized (permissionManager.errorLock) {
                // Only hold lock while making a safe copy of current error state
                managementErrorHappened = (permissionManager.managementRealmError != null);
                permissionErrorHappened = (permissionManager.permissionRealmError != null);
                defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
                managementError = permissionManager.managementRealmError;
                permissionError = permissionManager.permissionRealmError;
                defaultPermissionError = permissionManager.defaultPermissionRealmError;
            }

            // Everything seems valid
            if (!permissionErrorHappened && !managementErrorHappened) {// && !defaultPermissionErrorHappened) {
                return false;
            }

            // Handle Client Reset if it happened in any of the Realms.
            // A Client Reset is a fatal error for the PermissionManager, so all current and
            // future tasks will exit as soon as possible after this event happened and report it
            // through the error callback. Only action a user can take is to close the
            // PermissionManager and re-open it again. Some data might be lost (like permission
            // offers not yet processed). This is currently unavoidable.
            // TODO: Eventually we might be able to recover the permission manager from this event
            // but it will require some serious task management as we would need to do a full
            // close, reschedule all tasks, and re-open behind users back. This is out of scope for
            // now.
            if (managementErrorHappened && managementError instanceof ClientResetRequiredError) {
                ClientResetRequiredError cr = (ClientResetRequiredError) managementError;
                permissionManager.managementRealm.close();
                cr.executeClientReset();
                permissionManager.clientReset = true;
            }

            if (permissionErrorHappened && permissionError instanceof ClientResetRequiredError) {
                ClientResetRequiredError cr = (ClientResetRequiredError) permissionError;
                permissionManager.permissionRealm.close();
                cr.executeClientReset();
                permissionManager.clientReset = true;
            }

            if (defaultPermissionErrorHappened && defaultPermissionError instanceof ClientResetRequiredError) {
                ClientResetRequiredError cr = (ClientResetRequiredError) defaultPermissionError;
                permissionManager.defaultPermissionRealm.close();
                cr.executeClientReset();
                permissionManager.clientReset = true;
            }

            // Handle errors
            Map<String, ObjectServerError> errors = new LinkedHashMap<>();
            if (permissionManager.clientReset) {
                errors.put("ClientReset", new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET));
            } else {
                if (managementErrorHappened) { errors.put("Management Realm", managementError); }
                if (permissionErrorHappened) { errors.put("Permission Realm", permissionError); }
                if (defaultPermissionErrorHappened) { errors.put("Default Permission Realm", defaultPermissionError); }
            }
            notifyCallbackWithError(combineRealmErrors(errors)); // This will remove the task from the task list

            return true;
        }

