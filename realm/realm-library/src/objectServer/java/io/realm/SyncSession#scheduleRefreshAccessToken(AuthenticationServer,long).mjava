    private void scheduleRefreshAccessToken(final AuthenticationServer authServer, long expireDateInMs) {
            // calculate the delay time before which we should refresh the access_token,
            // we adjust to 10 second to proactively refresh the access_token before the session
            // hit the expire date on the token
            long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
            if (refreshAfter < 0) {
                // Token already expired
                RealmLog.debug("Expires time already reached for the access token, refresh as soon as possible");
                // we avoid refreshing directly to avoid an edge case where the client clock is ahead
                // of the server, causing all access_token received from the server to be always
                // expired, we will flood the server with refresh token requests then, so adding
                // a bit of delay is the best effort in this case.
                refreshAfter = REFRESH_MARGIN_DELAY;
            }

            RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");

            if (refreshTokenTask != null) {
                refreshTokenTask.cancel();
            }

            ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
                @Override
                public void run() {
                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
                        refreshAccessToken(authServer);
                    }
                }
            }, refreshAfter, TimeUnit.MILLISECONDS);
            refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
    }

