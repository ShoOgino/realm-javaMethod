    /**
     * Log a user out, destroying their server state, unregistering them from the SDK, and removing
     * any synced Realms associated with them, from on-disk storage on next app launch (or directly
     * if all instances are closed).
     * If the user is already logged out or in an error state, this method does nothing.
     *
     * This method should be called whenever the application is committed to not using a user again
     * unless they are recreated. Failing to call this method may result in unused files and metadata
     * needlessly taking up space.
     *
     * Once the Object Server has confirmed the logout any registered {@link AuthenticationListener}
     * will be notified and user credentials will be deleted from this device.
     */
//    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
//     <p>
//     Any Realms owned by the user will be deleted, when the application restart.
//     */
    // this is a fire and forget, end user should not worry about the state of the async query
    @SuppressWarnings("FutureReturnValueIgnored")
//    public void logOut() {
//        // Acquire lock to prevent users creating new instances
//        synchronized (Realm.class) {
//            if (!SyncManager.getUserStore().isActive(identity, authenticationUrl.toString())) {
//                return; // Already logged out status
//            }
//
//            // Mark the user as logged out in the ObjectStore
//            SyncManager.getUserStore().remove(identity, authenticationUrl.toString());
//
//            // invalidate all pending refresh_token queries
//            for (SyncConfiguration syncConfiguration : realms.keySet()) {
//                try {
//                    SyncSession session = SyncManager.getSession(syncConfiguration);
//                    session.clearScheduledAccessTokenRefresh();
//                } catch (IllegalStateException e) {
//                    if (!e.getMessage().contains("No SyncSession found")) {
//                        throw e;
//                    }// else no session, either the Realm was not opened or session was removed.
//                }
//            }
//
//            // Remove all local tokens, preventing further connections.
//            // don't remove identity as this SyncUser might be re-activated and we need
//            // to avoid throwing a mismatch SyncConfiguration in RealmCache if we have
//            // the similar SyncConfiguration using the same identity, but with different (new)
//            // refresh-token.
//            realms.clear();
//
//            // Finally revoke server token. The local user is logged out in any case.
//            final RealmObjectServer server = SyncManager.getAuthServer();
//            // don't reference directly the refreshToken inside the revoke request
//            // as it may revoke the newly acquired refresh_token
//            final Token refreshTokenToBeRevoked = refreshToken;
//
//            ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
//            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>(3) {
//
//                @Override
//                protected LogoutResponse execute() {
//                    return server.logout(refreshTokenToBeRevoked, getAuthenticationUrl());
//                }
//
//                @Override
//                protected void onSuccess(LogoutResponse response) {
//                    SyncManager.notifyUserLoggedOut(SyncUser.this);
//                }
//
//                @Override
//                protected void onError(LogoutResponse response) {
//                    RealmLog.error("Failed to log user out.\n" + response.getError().toString());
//                }
//            });
//        }
//    }

    /**
     * Changes this user's password. This is done synchronously and involves the network, so calling this method on the
     * Android UI thread will always crash.
     * <p>
     * <b>WARNING:</b> Changing a user's password through an authentication server that doesn't use HTTPS is a major
     * security flaw, and should only be done while testing.
     *
     * @param newPassword the user's new password.
     * @throws ObjectServerError if the password could not be changed.
     */
//    public void changePassword(final String newPassword) throws ObjectServerError {
//        //noinspection ConstantConditions
//        if (newPassword == null) {
//            throw new IllegalArgumentException("Not-null 'newPassword' required.");
//        }
//        RealmObjectServer authServer = SyncManager.getAuthServer();
//        ChangePasswordResponse response = authServer.changePassword(refreshToken, newPassword, getAuthenticationUrl());
//        if (!response.isValid()) {
//            throw response.getError();
//        }
//    }

    /**
     * Changes another user's password. This is done synchronously and involves the network, so calling this method on the
     * Android UI thread will always crash.
     * <p>
     * This user needs admin privilege in order to change someone else's password.
     * <p>
     * <b>WARNING:</b> Changing a user's password through an authentication server that doesn't use HTTPS is a major
     * security flaw, and should only be done while testing.
     *
     * @param userId identity ({@link #getIdentity()}) of the user we want to change the password for.
     * @param newPassword the user's new password.
     * @throws ObjectServerError if the password could not be changed.
     */
//    public void changePassword(final String userId, final String newPassword) throws ObjectServerError {
//        //noinspection ConstantConditions
//        if (newPassword == null) {
//            throw new IllegalArgumentException("Not-null 'newPassword' required.");
//        }
//
//        if (Util.isEmptyString(userId)) {
//            throw new IllegalArgumentException("None empty 'userId' required.");
//        }
//
//        if (userId.equals(getIdentity())) { // user want's to change his/her own password
//            changePassword(newPassword);
//
//        } else {
//            if (!isAdmin()) {
//                throw new IllegalStateException("User need to be admin in order to change another user's password.");
//            }
//
//            RealmObjectServer authServer = SyncManager.getAuthServer();
//            ChangePasswordResponse response = authServer.changePassword(refreshToken, userId, newPassword, getAuthenticationUrl());
//            if (!response.isValid()) {
//                throw response.getError();
//            }
//        }
//    }

    /**
     * Changes this user's password asynchronously.
     * <p>
     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
     * security flaw, and should only be done while testing.
     *
     * @param newPassword the user's new password.
     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     * @throws IllegalArgumentException if not on a Looper thread.
     */
//    public RealmAsyncTask changePasswordAsync(final String newPassword, final Callback<SyncUser> callback) {
//        checkLooperThread("Asynchronous changing password is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public SyncUser run() {
//                changePassword(newPassword);
//                return SyncUser.this;
//            }
//        }.start();
//    }

    /**
     * Changes another user's password asynchronously.
     * <p>
     * This user needs admin privilege in order to change someone else's password.
     *
     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
     * security flaw, and should only be done while testing.
     *
     * @param userId identity ({@link #getIdentity()}) of the user we want to change the password for.
     * @param newPassword the user's new password.
     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     * @throws IllegalArgumentException if not on a Looper thread.
     */
//    public RealmAsyncTask changePasswordAsync(final String userId, final String newPassword, final Callback<SyncUser> callback) {
//        checkLooperThread("Asynchronous changing password is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//
//        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public SyncUser run() {
//                changePassword(userId, newPassword);
//                return SyncUser.this;
//            }
//        }.start();
//    }


    /**
     * Request a password reset email to be sent to a user's email.
     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     *
     * @param email email that corresponds to the user's username.
     * @param authenticationUrl the url used to authenticate the user.
     * @throws IllegalStateException if this method is called on the UI thread.
     * @throws IllegalArgumentException if no email or authenticationUrl was provided.
     * @throws ObjectServerError if an error happened on the server.
     */
//    public static void requestPasswordReset(String email, String authenticationUrl) throws ObjectServerError {
//        if (Util.isEmptyString(email)) {
//            throw new IllegalArgumentException("Not-null 'email' required.");
//        }
//        URL authUrl = getUrl(authenticationUrl);
//        RealmObjectServer authServer = SyncManager.getAuthServer();
//        UpdateAccountResponse response = authServer.requestPasswordReset(email, authUrl);
//        if (!response.isValid()) {
//            throw response.getError();
//        }
//    }

    /**
     * Request a password reset email to be sent to a user's email.
     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     *
     * @param email email that corresponds to the user's username.
     * @param authenticationUrl the url used to authenticate the user.
     * @param callback callback when the request has completed or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     * @throws IllegalStateException if this method is called on a non-looper thread.
     * @throws IllegalArgumentException if no email or authenticationUrl was provided.
     */
//    public static RealmAsyncTask requestPasswordResetAsync(final String email, final String authenticationUrl, final Callback<Void> callback) {
//        checkLooperThread("Asynchronous requesting a password reset is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//
//        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public Void run() {
//                requestPasswordReset(email, authenticationUrl);
//                return null;
//            }
//        }.start();
//    }

    /**
     * Complete the password reset flow by using the reset token sent to the user's email as a one-time authorization
     * token to change the password.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     * <p>
     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token, and
     * navigate to a view that allows to change the password within the app.
     *
     * @param resetToken the token that was sent to the user's email address.
     * @param newPassword the user's new password.
     * @param authenticationUrl the url used to authenticate the user.
     * @throws IllegalStateException if this method is called on the UI thread.
     * @throws IllegalArgumentException if no {@code token} or {@code newPassword} was provided.
     * @throws ObjectServerError if an error happened on the server.
     */
//    public static void completePasswordReset(String resetToken, String newPassword, String authenticationUrl) {
//        if (Util.isEmptyString(resetToken)) {
//            throw new IllegalArgumentException("Not-null 'token' required.");
//        }
//        if (Util.isEmptyString(newPassword)) {
//            throw new IllegalArgumentException("Not-null 'newPassword' required.");
//        }
//        URL authUrl = getUrl(authenticationUrl);
//        RealmObjectServer authServer = SyncManager.getAuthServer();
//        UpdateAccountResponse response = authServer.completePasswordReset(resetToken, newPassword, authUrl);
//        if (!response.isValid()) {
//            throw response.getError();
//        }
//    }

    /**
     * Complete the password reset flow by using the reset token sent to the user's email as a one-time authorization
     * token to change the password.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     * <p>
     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token, and
     * navigate to a view that allows to change the password within the app.
     *
     * @param resetToken the token that was sent to the user's email address.
     * @param newPassword the user's new password.
     * @param authenticationUrl the url used to authenticate the user.
     * @param callback callback when the server has accepted the new password or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     * @throws IllegalStateException if this method is called on a non-looper thread.
     * @throws IllegalArgumentException if no {@code token} or {@code newPassword} was provided.
     */
//    public static RealmAsyncTask completePasswordResetAsync(final String resetToken,
//                                           final String newPassword,
//                                           final String authenticationUrl,
//                                           final Callback<Void> callback) throws ObjectServerError {
//        checkLooperThread("Asynchronously completing a password reset is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//
//        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public Void run() {
//                completePasswordReset(resetToken, newPassword, authenticationUrl);
//                return null;
//            }
//        }.start();
//    }

    /**
     * Request an email confirmation email to be sent to a user's email.
     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     *
     * @param email the email that corresponds to the user's username.
     * @param authenticationUrl the url used to authenticate the user.
     * @throws IllegalStateException if this method is called on the UI thread.
     * @throws IllegalArgumentException if no {@code email} was provided.
     * @throws ObjectServerError if an error happened on the server.
     */
//    public static void requestEmailConfirmation(String email, String authenticationUrl) throws ObjectServerError {
//        if (Util.isEmptyString(email)) {
//            throw new IllegalArgumentException("Not-null 'email' required.");
//        }
//        URL authUrl = getUrl(authenticationUrl);
//        RealmObjectServer authServer = SyncManager.getAuthServer();
//        UpdateAccountResponse response = authServer.requestEmailConfirmation(email, authUrl);
//        if (!response.isValid()) {
//            throw response.getError();
//        }
//    }

    /**
     * Request an email confirmation email to be sent to a user's email.
     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     *
     * @param email the email that corresponds to the user's username.
     * @param authenticationUrl the url used to authenticate the user.
     * @param callback callback when the request has completed or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     * @throws IllegalStateException if this method is called on a non-looper thread.
     * @throws IllegalArgumentException if no {@code email} was provided.
     */
//    public static RealmAsyncTask requestEmailConfirmationAsync(final String email, final String authenticationUrl, final Callback<Void> callback) {
//        checkLooperThread("Asynchronously requesting an email confirmation is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//
//        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public Void run() {
//                requestEmailConfirmation(email, authenticationUrl);
//                return null;
//            }
//        }.start();
//    }

    /**
     * Complete the email confirmation flow by using the confirmation token sent to the user's email as a one-time
     * authorization token to confirm their email.
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     * <p>
     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token,
     * and navigate to a view that allows to confirm the email within the app.
     *
     * @param confirmationToken the token that was sent to the user's email address.
     * @param authenticationUrl the url used to authenticate the user.
     * @throws IllegalStateException if this method is called on the UI thread.
     * @throws IllegalArgumentException if no {@code confirmationToken} was provided.
     * @throws ObjectServerError if an error happened on the server.
     */
//    public static void confirmEmail(String confirmationToken, String authenticationUrl) throws ObjectServerError {
//        if (Util.isEmptyString(confirmationToken)) {
//            throw new IllegalArgumentException("Not-null 'confirmationToken' required.");
//        }
//        URL authUrl = getUrl(authenticationUrl);
//        RealmObjectServer authServer = SyncManager.getAuthServer();
//        UpdateAccountResponse response = authServer.confirmEmail(confirmationToken, authUrl);
//        if (!response.isValid()) {
//            throw response.getError();
//        }
//    }

    /**
     * Complete the email confirmation flow by using the confirmation token sent to the user's email as a one-time
     * authorization token to confirm their email. This functionalit
     * <p>
     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
     * provider, and passed a valid email address as a username.
     * <p>
     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token,
     * and navigate to a view that allows to confirm the email within the app.
     *
     * @param confirmationToken the token that was sent to the user's email address.
     * @param authenticationUrl the url used to authenticate the user.
     * @param callback callback when the server has confirmed the email or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     * @throws IllegalStateException if this method is called on a non-looper thread.
     * @throws IllegalArgumentException if no {@code confirmationToken} was provided.
     */
//    public static RealmAsyncTask confirmEmailAsync(final String confirmationToken,
//                                            final String authenticationUrl,
//                                            final Callback<Void> callback) {
//        checkLooperThread("Asynchronously confirming an email is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//
//        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public Void run() {
//                confirmEmail(confirmationToken, authenticationUrl);
//                return null;
//            }
//        }.start();
//    }

    /**
     * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), look up and return user information for that user.
     *
     * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
     *                             In most cases this is different from the Realm Object Server-issued identity.
     * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
     *
     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
     * of an {@code invalid} provider or {@code providerId}.
     * @throws IllegalStateException if this method is called on the UI thread.
     * @throws IllegalArgumentException if no {@code providerUserIdentity} or {@code provider} string was provided.
     * @throws ObjectServerError if an error happened on the server.
     */
//    public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final String provider) throws ObjectServerError {
//        if (Util.isEmptyString(providerUserIdentity)) {
//            throw new IllegalArgumentException("'providerUserIdentity' cannot be empty.");
//        }
//
//        if (Util.isEmptyString(provider)) {
//            throw new IllegalArgumentException("'provider' cannot be empty.");
//        }
//
//        if (!isAdmin()) {
//            throw new IllegalArgumentException("SyncUser needs to be admin in order to lookup other users ID.");
//        }
//
//        RealmObjectServer authServer = SyncManager.getAuthServer();
//        LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerUserIdentity, getAuthenticationUrl());
//        if (!response.isValid()) {
//            if (response.getError().getErrorCode() == ErrorCode.UNKNOWN_ACCOUNT) {
//                return null;
//            } else {
//                throw response.getError();
//            }
//        } else {
//            return SyncUserInfo.fromLookupUserIdResponse(response);
//        }
//    }

    /**
     * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), asynchronously look up and return user information for that user.
     *
     * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
     *                             In most cases this is different from the Realm Object Server-issued identity.
     * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
     * @return representation of the async task that can be used to cancel it if needed.
     * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
     * as this method is called on.
     * @return representation of the async task that can be used to cancel it if needed.
     */
//    public RealmAsyncTask retrieveInfoForUserAsync(final String providerUserIdentity, final String provider, final Callback<SyncUserInfo> callback) {
//        checkLooperThread("Asynchronously retrieving user is only possible from looper threads.");
//        //noinspection ConstantConditions
//        if (callback == null) {
//            throw new IllegalArgumentException("Non-null 'callback' required.");
//        }
//
//        return new Request<SyncUserInfo>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
//            @Override
//            public SyncUserInfo run() throws ObjectServerError {
//                return retrieveInfoForUser(providerUserIdentity, provider);
//            }
//        }.start();
//    }

    private static void checkLooperThread(String errorMessage) {
        AndroidCapabilities capabilities = new AndroidCapabilities();
        capabilities.checkCanDeliverNotification(errorMessage);
    }

