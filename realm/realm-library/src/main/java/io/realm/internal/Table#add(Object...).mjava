    /**
     * Appends the specified row to the end of the table. For internal testing usage only.
     *
     * @param values values.
     * @return the row index of the appended row.
     */
    protected long add(Object... values) {
        long rowIndex = addEmptyRow();

        checkImmutable();

        // Check values types
        int columns = (int)getColumnCount();
        if (columns != values.length) {
            throw new IllegalArgumentException("The number of value parameters (" +
                    String.valueOf(values.length) +
                    ") does not match the number of columns in the table (" +
                    String.valueOf(columns) + ").");
        }
        RealmFieldType colTypes[] = new RealmFieldType[columns];
        for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
            Object value = values[columnIndex];
            RealmFieldType colType = getColumnType(columnIndex);
            colTypes[columnIndex] = colType;
            if (!colType.isValid(value)) {
                //String representation of the provided value type
                String providedType;
                if (value == null) {
                    providedType = "null";
                } else {
                    providedType = value.getClass().toString();
                }

                throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) +
                        ". Expected a value compatible with column type " + colType + ", but got " + providedType + ".");
            }
        }

        // Insert values
        for (long columnIndex = 0; columnIndex < columns; columnIndex++) {
            Object value = values[(int)columnIndex];
            switch (colTypes[(int)columnIndex]) {
            case BOOLEAN:
                nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
                break;
            case INTEGER:
                if (value == null) {
                    checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
                    nativeSetNull(nativePtr, columnIndex, rowIndex);
                } else {
                    long intValue = ((Number) value).longValue();
                    checkIntValueIsLegal(columnIndex, rowIndex, intValue);
                    nativeSetLong(nativePtr, columnIndex, rowIndex, intValue);
                }
                break;
            case FLOAT:
                nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value);
                break;
            case DOUBLE:
                nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value);
                break;
            case STRING:
                if (value == null) {
                    checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
                    nativeSetNull(nativePtr, columnIndex, rowIndex);
                } else {
                    String stringValue = (String) value;
                    checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
                    nativeSetString(nativePtr, columnIndex, rowIndex, (String) value);
                }
                break;
            case DATE:
                if (value == null)
                    throw new IllegalArgumentException("Null Date is not allowed.");
                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime());
                break;
            case BINARY:
                if (value == null)
                    throw new IllegalArgumentException("Null Array is not allowed");
                nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
                break;
            case UNSUPPORTED_MIXED:
            case UNSUPPORTED_TABLE:
            default:
                throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int)columnIndex]));
            }
        }
        return rowIndex;
    }

