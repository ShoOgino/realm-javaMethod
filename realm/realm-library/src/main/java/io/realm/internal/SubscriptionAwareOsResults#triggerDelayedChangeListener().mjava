    private void triggerDelayedChangeListener() {
        // Only parse on the subscription if it actually changed
        OsSubscription subscription = (subscriptionChanged) ? this.subscription : null;

        // In case no collection listener was triggered, only trigger the listener if non-relevant
        // changes happened to the subscription. In our case this means we only care about the
        // errors and a completed subscription
        if (delayedNotificationPtr == 0
                && subscription != null
                && subscription.getState() != OsSubscription.SubscriptionState.ERROR
                && subscription.getState() != OsSubscription.SubscriptionState.COMPLETE) {
            return;
        }

        OsCollectionChangeSet changeset;
        if (delayedNotificationPtr == 0) {
            changeset = new EmptyLoadChangeSet(subscription, firstCallback, true);
        } else {
            changeset = new OsCollectionChangeSet(delayedNotificationPtr, firstCallback, subscription, true);
        }

        // Happens e.g. if a synchronous query is created, a change listener is added and then
        // a transaction is started on the same thread. This will trigger all notifications
        // and deliver an empty changeset.
        if (changeset.isEmpty() && isLoaded()) {
            return;
        }
        loaded = true;
        firstCallback = false;
        observerPairs.foreach(new Callback(changeset));
    }

