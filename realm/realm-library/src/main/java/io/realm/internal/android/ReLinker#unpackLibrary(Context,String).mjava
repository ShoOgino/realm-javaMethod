    /**
     * Attempts to unpack the given library to the workaround directory. Implements retry logic for
     * IO operations to ensure they succeed.
     *
     * @param context {@link Context} to describe the location of the installed APK file
     * @param library The name of the library to load
     */
    @SuppressWarnings("ResultOfMethodCallIgnored")
    private static void unpackLibrary(final Context context, final String library) {
        ZipFile zipFile = null;
        try {
            final ApplicationInfo appInfo = context.getApplicationInfo();
            int tries = 0;
            while (tries++ < MAX_TRIES) {
                try {
                    zipFile = new ZipFile(new File(appInfo.sourceDir), ZipFile.OPEN_READ);
                    break;
                } catch (IOException ignored) {}
            }

            if (zipFile == null) {
                return;
            }

            tries = 0;
            while (tries++ < MAX_TRIES) {
                String jniNameInApk = null;
                ZipEntry libraryEntry = null;

                if (Build.VERSION.SDK_INT >= 21 && Build.SUPPORTED_ABIS.length > 0) {
                    for (final String ABI : Build.SUPPORTED_ABIS) {
                        jniNameInApk = "lib/" + ABI + "/" + System.mapLibraryName(library);
                        libraryEntry = zipFile.getEntry(jniNameInApk);

                        if (libraryEntry != null) {
                            break;
                        }
                    }
                } else {
                    //noinspection deprecation
                    jniNameInApk = "lib/" + Build.CPU_ABI + "/" + System.mapLibraryName(library);
                    libraryEntry = zipFile.getEntry(jniNameInApk);
                }

                if (libraryEntry == null) {
                    // Does not exist in the APK
                    if (jniNameInApk != null) {
                        throw new MissingLibraryException(jniNameInApk);
                    } else {
                        throw new MissingLibraryException(library);
                    }
                }

                final File outputFile = getWorkaroundLibFile(context, library);
                outputFile.delete(); // Remove any old file that might exist

                try {
                    if (!outputFile.createNewFile()) {
                        continue;
                    }
                } catch (IOException ignored) {
                    // Try again
                    continue;
                }

                InputStream inputStream = null;
                FileOutputStream fileOut = null;
                try {
                    inputStream = zipFile.getInputStream(libraryEntry);
                    fileOut = new FileOutputStream(outputFile);
                    copy(inputStream, fileOut);
                } catch (FileNotFoundException e) {
                    // Try again
                    continue;
                } catch (IOException e) {
                    // Try again
                    continue;
                } finally {
                    closeSilently(inputStream);
                    closeSilently(fileOut);
                }

                // Change permission to rwxr-xr-x
                outputFile.setReadable(true, false);
                outputFile.setExecutable(true, false);
                outputFile.setWritable(true);
                break;
            }
        } finally {
            try {
                if (zipFile != null) {
                    zipFile.close();
                }
            } catch (IOException ignored) {}
        }
    }

