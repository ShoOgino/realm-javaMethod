    /**
     * Add an empty row to the table and set the primary key with the given value.
     *
     * @param primaryKeyValue the primary key value.
     * @param validation set to {@code false} to skip all validations. This is currently used by bulk insert which
     *                     has its own validations.
     * @return the row index.
     */
    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation) {
        if (validation) {
            checkImmutable();
            checkHasPrimaryKey();
        }

        long primaryKeyColumnIndex = getPrimaryKey();
        RealmFieldType type = getColumnType(primaryKeyColumnIndex);
        long rowIndex;
        UncheckedRow row;

        // Add with primary key initially set
        if (primaryKeyValue == null) {
            switch (type) {
                case STRING:
                case INTEGER:
                    if (validation && findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
                        throwDuplicatePrimaryKeyException("null");
                    }
                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
                    row = getUncheckedRow(rowIndex);
                    // FIXME: Use core's set_null_unique when core supports it.
                    row.setNull(primaryKeyColumnIndex);
                    break;

                default:
                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
            }

        } else {
            switch (type) {
                case STRING:
                    if (!(primaryKeyValue instanceof String)) {
                        throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
                    }
                    if (validation && findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
                        throwDuplicatePrimaryKeyException(primaryKeyValue);
                    }
                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
                    nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, (String) primaryKeyValue);
                    break;

                case INTEGER:
                    long pkValue;
                    try {
                        pkValue = Long.parseLong(primaryKeyValue.toString());
                    } catch (RuntimeException e) {
                        throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
                    }
                    if (validation && findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
                        throwDuplicatePrimaryKeyException(pkValue);
                    }
                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
                    nativeSetLongUnique(nativePtr, primaryKeyColumnIndex, rowIndex, pkValue);
                    break;

                default:
                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
            }
        }
        return rowIndex;
    }

