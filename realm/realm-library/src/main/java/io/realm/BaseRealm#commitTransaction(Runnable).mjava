    /**
     * Commits transaction, runs the given runnable and then sends notifications. The runnable is useful to meet some
     * timing conditions like the async transaction. In async transaction, the background Realm has to be closed before
     * other threads see the changes to majoyly avoid the flaky tests.
     *
     * @param runAfterCommit runnable will run after transaction committed but before notification sent.
     */
    void commitTransaction(Runnable runAfterCommit) {
        checkIfValid();
        sharedGroupManager.commitAndContinueAsRead();

        if (runAfterCommit != null)  {
            runAfterCommit.run();
        }

        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
            Handler handler = handlerIntegerEntry.getKey();
            String realmPath = handlerIntegerEntry.getValue();

            // Notify at once on thread doing the commit
            if (handler.equals(this.handler)) {
                handlerController.notifyGlobalListeners();
                // notify RealmResults & RealmObject callbacks
                handlerController.notifyTypeBasedListeners();
                // if we have empty async RealmObject then rerun
                if (handlerController.threadContainsAsyncEmptyRealmObject()) {
                    handlerController.updateAsyncEmptyRealmObject();
                }
                continue;
            }

            // For all other threads, use the Handler
            // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
            // as the target thread consumes messages at the same time. In this case it is not a problem as worst
            // case we end up with two REALM_CHANGED messages in the queue.
            if (
                    realmPath.equals(configuration.getPath())            // It's the right realm
                            && !handler.hasMessages(HandlerController.REALM_CHANGED)       // The right message
                            && handler.getLooper().getThread().isAlive() // The receiving thread is alive
                            && !handler.sendEmptyMessage(HandlerController.REALM_CHANGED)) {
                RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
                        "to prevent this.");
            }
        }
    }

