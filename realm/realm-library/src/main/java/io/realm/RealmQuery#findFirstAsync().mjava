    /**
     * Similar to {@link #findFirst()} but runs asynchronously on a worker thread
     * This method is only available from a Looper thread.
     *
     * @return immediately an empty {@link RealmObject}. Trying to access any field on the returned object
     * before it is loaded will throw an {@code IllegalStateException}. Use {@link RealmObject#isLoaded()} to check if
     * the object is fully loaded or register a listener {@link io.realm.RealmObject#addChangeListener}
     * to be notified when the query completes. If no RealmObject was found after the query completed, the returned
     * RealmObject will have {@link RealmObject#isLoaded()} set to {@code true} and {@link RealmObject#isValid()} set to
     * {@code false}.
     */
    public E findFirstAsync() {
        checkQueryIsNotReused();
        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();

        // handover the query (to be used by a worker thread)
        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);

        // save query arguments (for future update)
        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_FIRST);

        final RealmConfiguration realmConfiguration = realm.getConfiguration();

        // prepare an empty reference of the RealmObject, so we can return it immediately (promise)
        // then update it once the query complete in the background.
        final E result;
        if (isDynamicQuery()) {
            //noinspection unchecked
            result = (E) new DynamicRealmObject(className, realm, Row.EMPTY_ROW);
        } else {
            result = realm.getConfiguration().getSchemaMediator().newInstance(
                    clazz, realm, Row.EMPTY_ROW, realm.getSchema().getColumnInfo(clazz),
                    false, Collections.<String>emptyList());
        }

        final RealmObjectProxy proxy = (RealmObjectProxy) result;
        final WeakReference<RealmObjectProxy> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(proxy, this);

        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
            @Override
            public Long call() throws Exception {
                if (!Thread.currentThread().isInterrupted()) {
                    SharedRealm sharedRealm = null;

                    try {
                        sharedRealm = SharedRealm.getInstance(realmConfiguration);

                        long handoverRowPointer = TableQuery.findWithHandover(sharedRealm, handoverQueryPointer);
                        if (handoverRowPointer == 0) { // empty row
                            realm.handlerController.addToEmptyAsyncRealmObject(realmObjectWeakReference, RealmQuery.this);
                            realm.handlerController.removeFromAsyncRealmObject(realmObjectWeakReference);
                        }

                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmObjectResponse();
                        result.updatedRow.put(realmObjectWeakReference, handoverRowPointer);
                        result.versionID = sharedRealm.getVersionID();
                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT, result);

                        return handoverRowPointer;

                    } catch (Throwable e) {
                        RealmLog.error(e);
                        // handler can't throw a checked exception need to wrap it into unchecked Exception
                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                    } finally {
                        if (sharedRealm != null && !sharedRealm.isClosed()) {
                            sharedRealm.close();
                        }
                    }
                } else {
                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
                }

                return INVALID_NATIVE_POINTER;
            }
        });
        proxy.realmGet$proxyState().setPendingQuery$realm(pendingQuery);

        return result;
    }

