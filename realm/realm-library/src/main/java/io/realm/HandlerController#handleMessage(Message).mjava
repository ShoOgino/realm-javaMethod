    @Override
    public boolean handleMessage(Message message) {
        // Due to how a ConcurrentHashMap iterator is created we cannot be sure that other threads are
        // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
        // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
        // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
        // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
        if (realm.sharedGroupManager != null) {
            QueryUpdateTask.Result result;
            switch (message.what) {

                case LOCAL_COMMIT:
                case REALM_CHANGED:
                    realmChanged(message.what == LOCAL_COMMIT);
                    break;

                case COMPLETED_ASYNC_REALM_RESULTS:
                    result = (QueryUpdateTask.Result) message.obj;
                    completedAsyncRealmResults(result);
                    break;

                case COMPLETED_ASYNC_REALM_OBJECT:
                    result = (QueryUpdateTask.Result) message.obj;
                    completedAsyncRealmObject(result);
                    break;

                case COMPLETED_UPDATE_ASYNC_QUERIES:
                    // this is called once the background thread completed the update of the async queries
                    result = (QueryUpdateTask.Result) message.obj;
                    completedAsyncQueriesUpdate(result);
                    break;

                case REALM_ASYNC_BACKGROUND_EXCEPTION:
                    // Don't fail silently in the background in case of Core exception
                    throw (Error) message.obj;

                default:
                    throw new IllegalArgumentException("Unknown message: " + message.what);
            }
        }
        return true;
    }

