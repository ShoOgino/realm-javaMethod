    @Override
    public boolean handleMessage(Message message) {
        // Due to how a ConcurrentHashMap iterator is created we cannot be sure that other threads are
        // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
        // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
        // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
        // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
        if (realm.sharedGroupManager != null) {
            switch (message.what) {
                case REALM_CHANGED: {
                    realmChanged();
                    break;
                }
                case COMPLETED_ASYNC_REALM_RESULTS: {
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
                    completedAsyncRealmResults(result);
                    break;
                }
                case COMPLETED_ASYNC_REALM_OBJECT: {
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
                    completedAsyncRealmObject(result);
                    break;
                }
                case COMPLETED_UPDATE_ASYNC_QUERIES: {
                    // this is called once the background thread completed the update of the async queries
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
                    completedAsyncQueriesUpdate(result);
                    break;
                }

                case REALM_ASYNC_BACKGROUND_EXCEPTION: {
                    // Don't fail silently in the background in case of Core exception
                    throw (Error) message.obj;
                }
            }
        }
        return true;
    }

