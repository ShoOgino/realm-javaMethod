    /**
     * Finds all objects that fulfil the query condition(s). This method is only available from a Looper thread.
     * <p>
     * This method is only available on query-based synchronized Realms and will also create a named subscription
     * that will synchronize all server data matching the query. Named subscriptions can be removed again by
     * calling {@code Realm.unsubscribe(subscriptionName}.
     *
     * @param subscriptionName name of the underlying subscription being created.
     * @param timeToLive the amount of time the Subscription must be kept alive after last being used. After this
     *                   period Realm will automatically remove it.
     * @param timeUnit the unit for {@code timeToLive}.
     * @param update if an existing subscription exists with a different query. It will be replaced with this
     *               one instead of an error being reported through {@link OrderedRealmCollectionChangeListener}.
     * @return immediately an empty {@link RealmResults}. Users need to register a listener
     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
     * @see io.realm.RealmResults
     * @throws IllegalStateException If the Realm is a not a query-based synchronized Realm or the query is on a {@link RealmList}.
     */
    @ObjectServer
    @Beta
    public RealmResults<E> findAllAsync(String subscriptionName, long timeToLive, TimeUnit timeUnit, boolean update) {
        realm.checkIfValid();
        realm.checkIfPartialRealm();
        if (osList != null) {
            throw new IllegalStateException("Cannot create subscriptions for queries based on a 'RealmList'");
        }
        if (Util.isEmptyString(subscriptionName)) {
            throw new IllegalArgumentException("Non-empty 'subscriptionName' required.");
        }
        if (timeToLive < 0) {
            throw new IllegalArgumentException("Negative values for 'timeToLive' are not allowed: " + timeToLive);
        }
        //noinspection ConstantConditions
        if (timeUnit == null) {
            throw new IllegalArgumentException("Non-null 'timeUnit' required.");
        }
        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
        long timeToLiveMs = timeUnit.toMillis(timeToLive);
        SubscriptionAction action = (update) ? SubscriptionAction.update(subscriptionName, timeToLiveMs) : SubscriptionAction.create(subscriptionName, timeToLiveMs);
        return createRealmResults(query, queryDescriptors, false, action);
    }

