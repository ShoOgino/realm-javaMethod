    /**
     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously from a worker thread.
     *
     * @param transaction {@link io.realm.Realm.Transaction} to execute.
     * @param callback optional, to receive the result of this query.
     * @return a {@link RealmAsyncTask} representing a cancellable task.
     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
     */
    public RealmAsyncTask executeTransaction(final Transaction transaction, final Transaction.Callback callback) {
        if (transaction == null)
            throw new IllegalArgumentException("Transaction should not be null");

        // If the user provided a Callback then we make sure, the current Realm has a Handler
        // we can use to deliver the result
        if (callback != null && handler == null) {
            throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
                    " and you provided a callback, we need a Handler to invoke your callback");
        }

        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
        // to perform the transaction
        final RealmConfiguration realmConfiguration = getConfiguration();

        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
            @Override
            public void run() {
                if (!Thread.currentThread().isInterrupted()) {
                    Realm bgRealm = Realm.getInstance(realmConfiguration);
                    bgRealm.beginTransaction();
                    try {
                        transaction.execute(bgRealm);

                        if (!Thread.currentThread().isInterrupted()) {
                            bgRealm.commitTransaction();
                            if (callback != null
                                    && handler != null
                                    && !Thread.currentThread().isInterrupted()
                                    && handler.getLooper().getThread().isAlive()) {
                                // The bgRealm needs to be closed before post event to caller's handler to avoid concurrency problem
                                // eg.: User wants to delete Realm in the callbacks.
                                bgRealm.close();
                                handler.post(new Runnable() {
                                    @Override
                                    public void run() {
                                        callback.onSuccess();
                                    }
                                });
                            }
                        } else {
                            if (bgRealm.isInTransaction()) {
                                bgRealm.cancelTransaction();
                            } else {
                                RealmLog.w("Thread is interrupted. Could not cancel transaction, not currently in a transaction.");
                            }
                        }

                    } catch (final Exception e) {
                        if (bgRealm.isInTransaction()) {
                            bgRealm.cancelTransaction();
                        } else {
                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
                        }
                        if (callback != null
                                && handler != null
                                && !Thread.currentThread().isInterrupted()
                                && handler.getLooper().getThread().isAlive()) {
                            bgRealm.close();
                            handler.post(new Runnable() {
                                @Override
                                public void run() {
                                    callback.onError(e);
                                }
                            });
                        }
                    } finally {
                        if (!bgRealm.isClosed()) {
                            bgRealm.close();
                        }
                    }
                }
            }
        });

        return new RealmAsyncTask(pendingQuery);
    }

