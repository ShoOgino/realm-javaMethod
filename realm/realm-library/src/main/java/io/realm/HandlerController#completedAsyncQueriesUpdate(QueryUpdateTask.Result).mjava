    private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
        SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
        int compare = callerVersionID.compareTo(result.versionID);
        if (compare > 0) {
            // if the caller thread is more advanced than the worker thread, it means it did a local commit.
            // This should also have put a REALM_CHANGED event on the Looper queue, so ignoring this result should
            // be safe as all async queries will be rerun when processing the REALM_CHANGED event.
            RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, Looper will updates queries");

        } else {
            // We're behind or on the same version as the worker thread

            // only advance if we're behind
            if (compare != 0) {
                // no need to remove old pointers from TableView, since they're
                // imperative TV, they will not rerun if the SharedGroup advance

                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " caller is behind  advance_read");
                // refresh the Realm to the version provided by the worker thread
                // (advanceRead to the latest version may cause a version mismatch error) preventing us
                // from importing correctly the handover table view
                try {
                    realm.sharedGroupManager.advanceRead(result.versionID);
                } catch (BadVersionException e) {
                    // The version comparison above should have ensured that that the Caller version is less than the
                    // Worker version. In that case it should always be safe to advance_read.
                    throw new IllegalStateException("Failed to advance Caller Realm to Worker Realm version", e);
                }
            }

            // It's dangerous to notify the callback about new results before updating
            // the pointers, because the callback may use another RealmResults not updated yet
            // this is why we defer the notification until we're done updating all pointers.
            ArrayList<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
            for (Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, Long> query : result.updatedTableViews.entrySet()) {
                WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = query.getKey();
                RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
                if (realmResults == null) {
                    // don't update GC'd instance
                    asyncRealmResults.remove(weakRealmResults);

                } else {
                    // update the instance with the new pointer
                    realmResults.swapTableViewPointer(query.getValue());
                    realmResults.syncIfNeeded();
                    resultsToBeNotified.add(realmResults);

                    RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
                }
            }
            collectSyncRealmResultsCallbacks(resultsToBeNotified);

            // We need to notify all listeners, since the original REALM_CHANGE
            // was delayed/swallowed in order to be able to update the async queries.
            notifyAllListeners(resultsToBeNotified);

            updateAsyncQueriesTask = null;
        }
    }

