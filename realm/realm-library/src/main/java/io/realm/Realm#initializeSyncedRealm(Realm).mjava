    // Everything in this method needs to be behind a transaction lock
    // to prevent multi-process interaction while the Realm is initialized.
    private static void initializeSyncedRealm(Realm realm) {
        boolean commitChanges = false;
        OsRealmSchema schema = null;
        OsRealmSchema.Creator schemaCreator = null;
        try {
            // We need to start a transaction no matter readOnly mode, because it acts as an interprocess lock.
            // TODO: For proper inter-process support we also need to move e.g copying the asset file under an
            // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
            // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
            realm.beginTransaction(true);
            long currentVersion = realm.getVersion();
            final boolean unversioned = currentVersion == UNVERSIONED;

            RealmConfiguration configuration = realm.getConfiguration();

            final RealmProxyMediator mediator = configuration.getSchemaMediator();
            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();

            long newVersion = configuration.getSchemaVersion();

            // Update/create the schema if allowed
            if (!configuration.isReadOnly()) {
                schemaCreator = new OsRealmSchema.Creator();
                for (Class<? extends RealmModel> modelClass : modelClasses) {
                    mediator.createRealmObjectSchema(modelClass, schemaCreator);
                }

                // Assumption: When SyncConfiguration then additive schema update mode.
                schema = new OsRealmSchema(schemaCreator);
                schemaCreator.close();
                schemaCreator = null;

                // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
                // It absolutely breaks encapsulation and needs to be fixed!
                if (realm.sharedRealm.requiresMigration(schema.getNativePtr())) {
                    if (currentVersion >= newVersion) {
                        throw new IllegalArgumentException(String.format(
                                "The schema was changed but the schema version was not updated. " +
                                        "The configured schema version (%d) must be greater than the version " +
                                        " in the Realm file (%d) in order to update the schema.",
                                newVersion, currentVersion));
                    }
                    realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
                    // The OS currently does not handle setting the schema version. We have to do it manually.
                    realm.setVersion(newVersion);
                    commitChanges = true;
                }
            }

            // Validate the schema in the file
            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
            for (Class<? extends RealmModel> modelClass : modelClasses) {
                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
            }
            realm.getSchema().setInitialColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);

            if (unversioned && !configuration.isReadOnly()) {
                final Transaction transaction = configuration.getInitialDataTransaction();
                if (transaction != null) {
                    transaction.execute(realm);
                }
            }
        } catch (RuntimeException e) {
            commitChanges = false;
            throw e;
        } finally {
            if (schemaCreator != null) {
                schemaCreator.close();
            }
            if (schema != null) {
                schema.close();
            }
            if (commitChanges) {
                realm.commitTransaction();
            } else {
                realm.cancelTransaction();
            }
        }
    }

