    // Everything in this method needs to be behind a transaction lock
    // to prevent multi-process interaction while the Realm is initialized.
    private static void initializeSyncedRealm(Realm realm) {
        boolean commitChanges = false;
        OsRealmSchema schema = null;
        OsRealmSchema.Creator schemaCreator = null;
        try {
            // We need to start a transaction no matter readOnly mode, because it acts as an interprocess lock.
            // TODO: For proper inter-process support we also need to move e.g copying the asset file under an
            // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
            // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
            realm.beginTransaction(true);
            long currentVersion = realm.getVersion();
            final boolean unversioned = currentVersion == UNVERSIONED;

            RealmConfiguration configuration = realm.getConfiguration();

            final RealmProxyMediator mediator = configuration.getSchemaMediator();
            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();

            long newVersion = configuration.getSchemaVersion();

            // Update/create the schema if allowed
            if (!configuration.isReadOnly()) {
                schemaCreator = new OsRealmSchema.Creator();
                for (Class<? extends RealmModel> modelClass : modelClasses) {
                    mediator.createRealmObjectSchema(modelClass, schemaCreator);
                }

                // Assumption: When SyncConfiguration then additive schema update mode.
                schema = new OsRealmSchema(schemaCreator);
                schemaCreator.close();
                schemaCreator = null;

                // Object Store handles all update logic
                realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
                commitChanges = true;
            }

            // Validate the schema in the file
            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
            for (Class<? extends RealmModel> modelClass : modelClasses) {
                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
            }
            realm.getSchema().setInitialColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);

            if (unversioned && !configuration.isReadOnly()) {
                final Transaction transaction = configuration.getInitialDataTransaction();
                if (transaction != null) {
                    transaction.execute(realm);
                }
            }
        } catch (RuntimeException e) {
            commitChanges = false;
            throw e;
        } finally {
            if (schemaCreator != null) {
                schemaCreator.close();
            }
            if (schema != null) {
                schema.close();
            }
            if (commitChanges) {
                realm.commitTransaction();
            } else {
                realm.cancelTransaction();
            }
        }
    }

