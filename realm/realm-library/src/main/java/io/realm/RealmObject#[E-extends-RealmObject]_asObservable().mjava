    /**
     * Returns an Rx Observable that monitors changes to this RealmObject. It will emit the current object when
     * subscribed to.
     *
     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
     * type information, otherwise the type of the following observables will be {@code RealmObject}.
     *
     * @param <E> RealmObject class that is being observed. Must be this class or its super types.
     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
     */
    public <E extends RealmObject> Observable<E> asObservable() {
        if (realm instanceof Realm) {
            @SuppressWarnings("unchecked")
            E obj = (E) this;
            return realm.configuration.getRxFactory().from((Realm) realm, obj);
        } else if (realm instanceof DynamicRealm) {
            DynamicRealm dynamicRealm = (DynamicRealm) realm;
            DynamicRealmObject dynamicObject = (DynamicRealmObject) this;
            @SuppressWarnings("unchecked")
            Observable<E> observable = (Observable<E>) realm.configuration.getRxFactory().from(dynamicRealm, dynamicObject);
            return observable;
        } else {
            throw new UnsupportedOperationException(realm.getClass() + " not supported");
        }
    }

