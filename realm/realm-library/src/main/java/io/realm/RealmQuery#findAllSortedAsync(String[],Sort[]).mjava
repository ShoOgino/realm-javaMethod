    /**
     * Similar to {@link #findAllSorted(String[], Sort[])} but runs asynchronously
     * from a worker thread.
     * This method is only available from a Looper thread.
     *
     * @return immediately an empty {@link RealmResults}. Users need to register a listener
     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
     * @see io.realm.RealmResults
     * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
     * {@link RealmObject} or a child {@link RealmList}.
     */
    public RealmResults<E> findAllSortedAsync(String fieldNames[], final Sort[] sortOrders) {
        checkQueryIsNotReused();
        checkSortParameters(fieldNames, sortOrders);

        if (fieldNames.length == 1 && sortOrders.length == 1) {
            return findAllSortedAsync(fieldNames[0], sortOrders[0]);

        } else {
            final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();

            // Handovers the query (to be used by a worker thread).
            final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);

            // We need to use the same configuration to open a background SharedRealm to perform the query.
            final RealmConfiguration realmConfiguration = realm.getConfiguration();

            final long indices[] = new long[fieldNames.length];
            for (int i = 0; i < fieldNames.length; i++) {
                String fieldName = fieldNames[i];
                long columnIndex = getColumnIndexForSort(fieldName);
                indices[i] = columnIndex;
            }

            // Captures the query arguments for future retries & update.
            argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED);
            argumentsHolder.sortOrders = sortOrders;
            argumentsHolder.columnIndices = indices;

            // Prepares the promise result.
            RealmResults<E> realmResults;
            if (isDynamicQuery()) {
                //noinspection unchecked
                realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
            } else {
                realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
            }

            final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);

            final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
                @Override
                public Long call() throws Exception {
                    if (!Thread.currentThread().isInterrupted()) {
                        SharedRealm sharedRealm = null;

                        try {
                            sharedRealm = SharedRealm.getInstance(realmConfiguration);

                            // Runs the query & handover the table view for the caller thread.
                            long handoverTableViewPointer = TableQuery.findAllMultiSortedWithHandover(sharedRealm,
                                    handoverQueryPointer, indices, sortOrders);

                            QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                            result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                            result.versionID = sharedRealm.getVersionID();
                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                    weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);

                            return handoverTableViewPointer;
                        } catch (BadVersionException e) {
                            // In some rare race conditions, this can happen. In that case, just ignore the error.
                            RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                    "Retry is scheduled by a REALM_CHANGED event.");

                        } catch (Throwable e) {
                            RealmLog.error(e);
                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                    weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                        } finally {
                            if (sharedRealm != null && !sharedRealm.isClosed()) {
                                sharedRealm.close();
                            }
                        }
                    } else {
                        TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
                    }

                    return INVALID_NATIVE_POINTER;
                }
            });

            realmResults.setPendingQuery(pendingQuery);
            return realmResults;
        }
    }

