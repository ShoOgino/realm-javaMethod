    /**
     * Updates own schema cache.
     *
     * @param globalCacheArray global cache of column indices. If it contains an entry for current
     * schema version, this method only copies the indices information in the entry.
     * @return newly created indices information for current schema version. Or {@code null} if {@code globalCacheArray}
     * already contains the entry for current schema version.
     */
    ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
        final long currentSchemaVersion = sharedRealm.getSchemaVersion();
        final long cacheSchemaVersion = schema.getSchemaVersion();
        if (currentSchemaVersion == cacheSchemaVersion) {
            return null;
        }

        ColumnIndices createdGlobalCache = null;
        ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
                currentSchemaVersion);
        if (cacheForCurrentVersion == null) {
            final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();

            // Not found in global cache. create it.
            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
            final Map<Class<? extends RealmModel>, ColumnInfo> map;
            map = new HashMap<>(modelClasses.size());


            // This code may throw a RealmMigrationNeededException
            //noinspection CaughtExceptionImmediatelyRethrown
            try {
                for (Class<? extends RealmModel> clazz : modelClasses) {
                    final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
                    map.put(clazz, columnInfo);
                }
            } catch (RealmMigrationNeededException e) {
                throw e;
            }

            cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
        }
        schema.updateColumnIndices(cacheForCurrentVersion);
        return createdGlobalCache;
    }

