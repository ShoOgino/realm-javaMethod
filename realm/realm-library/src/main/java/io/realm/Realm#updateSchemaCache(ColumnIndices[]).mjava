    /**
     * Updates own schema cache.
     *
     * @param globalCacheArray global cache of column indices. If it contains an entry for current
     *                         schema version, this method only copies the indices information in the entry.
     * @return newly created indices information for current schema version. Or {@code null} if
     *         {@code globalCacheArray} already contains the entry for current schema version.
     */
    ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
        final long currentSchemaVersion = sharedRealm.getSchemaVersion();
        final long cacheSchemaVersion = schema.columnIndices.getSchemaVersion();
        if (currentSchemaVersion == cacheSchemaVersion) {
            return null;
        }

        ColumnIndices createdGlobalCache = null;
        final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
        ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
                currentSchemaVersion);
        if (cacheForCurrentVersion == null) {
            // not found in global cache. create it.
            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
            final Map<Class<? extends RealmModel>, ColumnInfo> map;
            map = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
            try {
                for (Class<? extends RealmModel> clazz : modelClasses) {
                    final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
                    map.put(clazz, columnInfo);
                }
            } catch (RealmMigrationNeededException e) {
                throw e;
            }

            cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
        }
        schema.columnIndices.copyFrom(cacheForCurrentVersion, mediator);
        return createdGlobalCache;
    }

