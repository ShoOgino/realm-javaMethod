    /**
     * Asynchronously returns a distinct set of objects of a specific class. If the result is
     * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
     * undefined which object is returned.
     *
     * @param fieldName the field name.
     * @return immediately a {@link RealmResults}. Users need to register a listener
     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
     * query completes.
     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
     * is not indexed, or points to linked fields.
     */
    public RealmResults<E> distinctAsync(String fieldName) {
        checkQueryIsNotReused();
        final long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();

        // handover the query (to be used by a worker thread)
        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);

        // save query arguments (for future update)
        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_DISTINCT);
        argumentsHolder.columnIndex = columnIndex;

        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
        // to perform the query
        final RealmConfiguration realmConfiguration = realm.getConfiguration();

        // prepare an empty reference of the RealmResults, so we can return it immediately (promise)
        // then update it once the query completes in the background.
        RealmResults<E> realmResults;
        if (isDynamicQuery()) {
            //noinspection unchecked
            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
        } else {
            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
        }

        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);

        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
            @Override
            public Long call() throws Exception {
                if (!Thread.currentThread().isInterrupted()) {
                    SharedRealm sharedRealm = null;

                    try {
                        sharedRealm = SharedRealm.getInstance(realmConfiguration);

                        long handoverTableViewPointer = TableQuery.
                                findDistinctWithHandover(sharedRealm,
                                        handoverQueryPointer,
                                        columnIndex);

                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                        result.versionID = sharedRealm.getVersionID();
                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);

                        return handoverTableViewPointer;
                    } catch (Throwable e) {
                        RealmLog.e(e.getMessage(), e);
                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                    } finally {
                        if (sharedRealm != null && !sharedRealm.isClosed()) {
                            sharedRealm.close();
                        }
                    }
                } else {
                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
                }

                return INVALID_NATIVE_POINTER;
            }
        });

        realmResults.setPendingQuery(pendingQuery);
        return realmResults;
    }

