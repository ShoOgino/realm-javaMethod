    /**
     * This predicate is only relevant for Query-based Realms.
     * <p>
     * Objects referenced through fields marked with {@link io.realm.annotations.LinkingObjects} are normally not downloaded
     * as part of the subscription in Query-based Realms, but by using this predicate, it is possible to specify which linking
     * objects relationships should also be included in the subscription as well.
     * <p>
     * Note, that all "forward" object references like object references and lists are always downloaded as part of the
     * subscription by default.
     * <p>
     * This predicate can be called multiple times, in which case all fields will be added to the subscription.
     * <p>
     * NOTE: This method is only supported when connecting to Realm Object Server 3.21.0 or later. If you use it with previous
     * versions of Realm Object Server, an {@link IllegalArgumentException} will be sent to {@link OrderedCollectionChangeSet#getError()}.
     *
     * @param firstIncludePath the first {@link io.realm.annotations.LinkingObjects} field to add.
     * @param remainingFieldPaths any remaining {@link io.realm.annotations.LinkingObjects} fields to add.
     * @throws IllegalStateException if called on a non-query-based Realm.
     * @throws IllegalArgumentException if the path does not end with a field marked with {@link io.realm.annotations.LinkingObjects}.
     */
    @ObjectServer
    public RealmQuery<E> includeLinkingObjects(String firstIncludePath, @Nullable String... remainingFieldPaths) {
        realm.checkIfValid();
        if (!ObjectServerFacade.getSyncFacadeIfPossible().isPartialRealm(realm.getConfiguration())) {
            throw new IllegalStateException("This method is only available for Query-based Realms.");
        }
        if (Util.isEmptyString(firstIncludePath)) {
            throw new IllegalArgumentException("Non-empty 'firstIncludePath' required.");
        }
        queryDescriptors.appendIncludes(IncludeDescriptor.createInstance(getSchemaConnector(), table, firstIncludePath));
        if (remainingFieldPaths != null) {
            //noinspection ForLoopReplaceableByForEach
            for (int i = 0; i < remainingFieldPaths.length; i++) {
                queryDescriptors.appendIncludes(IncludeDescriptor.createInstance(getSchemaConnector(), table, remainingFieldPaths[i]));
            }
        }
        return this;
    }

