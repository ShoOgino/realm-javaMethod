    /**
     * Similar to {@link #findAllSorted(String, Sort)} but runs asynchronously on a worker thread
     * (Need a Realm opened from a looper thread to work).
     *
     * @return immediately an empty {@link RealmResults}. Users need to register a listener
     *         {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
     * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
     * {@link RealmObject} or a child {@link RealmList}.
     */
    public RealmResults<E> findAllSortedAsync(final String fieldName, final Sort sortOrder) {
        checkQueryIsNotReused();
        long columnIndex = getColumnIndexForSort(fieldName);

        // capture the query arguments for future retries & update
        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_SORTED);
        argumentsHolder.sortOrder = sortOrder;
        argumentsHolder.columnIndex = columnIndex;

        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();

        // handover the query (to be used by a worker thread)
        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());

        // we need to use the same configuration to open a background SharedGroup to perform the query
        final RealmConfiguration realmConfiguration = realm.getConfiguration();

        RealmResults<E> realmResults;
        if (isDynamicQuery()) {
            //noinspection unchecked
            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
        } else {
            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
        }

        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults =
                realm.handlerController.addToAsyncRealmResults(realmResults, this);

        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
            @Override
            public Long call() throws Exception {
                if (!Thread.currentThread().isInterrupted()) {
                    SharedGroup sharedGroup = null;

                    try {
                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
                                SharedGroup.IMPLICIT_TRANSACTION,
                                realmConfiguration.getDurability(),
                                realmConfiguration.getEncryptionKey());

                        long columnIndex = getColumnIndexForSort(fieldName);

                        // run the query & handover the table view for the caller thread
                        long handoverTableViewPointer = query.findAllSortedWithHandover(sharedGroup.getNativePointer(),
                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, columnIndex, sortOrder);

                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                        result.versionID = sharedGroup.getVersion();
                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);

                        return handoverTableViewPointer;
                    } catch (BadVersionException e) {
                        // In some rare race conditions, this can happen. In that case, just ignore the error.
                        RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                "Retry is scheduled by a REALM_CHANGED event.");

                    } catch (Exception e) {
                        RealmLog.e(e.getMessage(), e);
                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));

                    } finally {
                        if (sharedGroup != null && !sharedGroup.isClosed()) {
                            sharedGroup.close();
                        }
                    }
                } else {
                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
                }

                return INVALID_NATIVE_POINTER;
            }
        });
        realmResults.setPendingQuery(pendingQuery);
        return realmResults;
    }

