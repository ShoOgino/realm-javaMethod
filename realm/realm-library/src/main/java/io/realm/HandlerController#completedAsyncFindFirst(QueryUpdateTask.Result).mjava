    private void completedAsyncFindFirst(QueryUpdateTask.Result result) {
        Set<WeakReference<? extends RealmObject>> updatedRowKey = result.updatedRow.keySet();
        if (updatedRowKey.size() > 0) {
            WeakReference<? extends RealmObject> realmObjectWeakReference = updatedRowKey.iterator().next();
            RealmObject realmObject = realmObjectWeakReference.get();

            if (realmObject != null) {
                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
                int compare = callerVersionID.compareTo(result.versionID);
                // we always query on the same version
                // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
                if (compare == 0) { //same version import the handover
                    realmObject.onCompleted(result.updatedRow.get(realmObjectWeakReference));
                    asyncRealmObjects.remove(realmObjectWeakReference);

                } else if (compare > 0) {
                    // the caller has advanced we need to
                    // retry against the current version of the caller
                    RealmQuery<?> realmQuery = asyncRealmObjects.get(realmObjectWeakReference);

                    QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                            .realmConfiguration(realm.getConfiguration())
                            .addObject(realmObjectWeakReference,
                                    realmQuery.handoverQueryPointer(),
                                    realmQuery.getArgument())
                            .sendToHandler(realm.handler, REALM_COMPLETED_ASYNC_FIND_FIRST)
                            .build();

                    Realm.asyncQueryExecutor.submit(queryUpdateTask);
                } else {
                    // should not happen, since the the background thread position itself against the provided version
                    // and the caller thread can only go forward (advance_read)
                    throw new IllegalStateException("Caller thread behind the worker thread");
                }
            } // else: element GC'd in the meanwhile
        }
    }

