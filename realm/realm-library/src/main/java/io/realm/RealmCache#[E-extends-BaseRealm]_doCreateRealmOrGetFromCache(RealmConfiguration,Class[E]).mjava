    private synchronized <E extends BaseRealm> E doCreateRealmOrGetFromCache(RealmConfiguration configuration,
            Class<E> realmClass) {

        RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.valueOf(realmClass));
        boolean firstRealmInstanceInProcess = (getTotalGlobalRefCount() == 0);
        boolean realmFileIsBeingCreated = !configuration.realmExists();

        if (firstRealmInstanceInProcess) {
            copyAssetFileIfNeeded(configuration);
            OsSharedRealm sharedRealm = null;
            try {
                if (configuration.isSyncConfiguration()) {
                    // If waitForInitialRemoteData() was enabled, we need to make sure that all data is downloaded
                    // before proceeding. We need to open the Realm instance first to start any potential underlying
                    // SyncSession so this will work.
                    if (realmFileIsBeingCreated) {
                        sharedRealm = OsSharedRealm.getInstance(configuration);
                        try {
                            ObjectServerFacade.getSyncFacadeIfPossible().downloadInitialRemoteChanges(configuration);
                        } catch (Throwable t) {
                            // If an error happened while downloading initial data, we need to reset the file so we can
                            // download it again on the next attempt.
                            sharedRealm.close();
                            sharedRealm = null;
                            deleteRealmFileOnDisk(configuration);
                            throw t;
                        }
                    }
                } else {
                    if (!realmFileIsBeingCreated) {
                        // Primary key problem only exists before we release sync.
                        sharedRealm = OsSharedRealm.getInstance(configuration);
                        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
                    }
                }
            } finally {
                if (sharedRealm != null) {
                    sharedRealm.close();
                }
            }

            // We are holding the lock, and we can set the valid configuration since there is no global ref to it.
            this.configuration = configuration;
        } else {
            // Throws exception if validation failed.
            validateConfiguration(configuration);
        }

        if (refAndCount.localRealm.get() == null) {
            // Creates a new local Realm instance
            BaseRealm realm;

            if (realmClass == Realm.class) {
                // RealmMigrationNeededException might be thrown here.
                realm = Realm.createInstance(this);

                // If `waitForInitialRemoteData` data is set, we also want to ensure that all subscriptions
                // are fully ACTIVE before proceeding. Most of the Realm is initialized during a write
                // transaction. So we cannot download subscription data until all other initializers have run.
                // At this point we also have access to all normal APIs as the schema is fully initialized.
                synchronizeInitialSubscriptionsIfNeeded((Realm) realm, realmFileIsBeingCreated);

            } else if (realmClass == DynamicRealm.class) {
                realm = DynamicRealm.createInstance(this);
            } else {
                throw new IllegalArgumentException(WRONG_REALM_CLASS_MESSAGE);
            }

            // The Realm instance has been created without exceptions. Cache and reference count can be updated now.
            refAndCount.localRealm.set(realm);
            refAndCount.localCount.set(0);

            // This is the first instance in current thread, increase the global count.
            refAndCount.globalCount++;
        }

        Integer refCount = refAndCount.localCount.get();
        refAndCount.localCount.set(refCount + 1);

        //noinspection unchecked
        return (E) refAndCount.localRealm.get();
    }

