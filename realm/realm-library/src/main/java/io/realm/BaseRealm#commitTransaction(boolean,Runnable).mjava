    /**
     * Commits transaction, runs the given runnable and then sends notifications. The runnable is useful to meet some
     * timing conditions like the async transaction. In async transaction, the background Realm has to be closed before
     * other threads see the changes to majoyly avoid the flaky tests.
     *
     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change listeners.
     * @param runAfterCommit runnable will run after transaction committed but before notification sent.
     */
    void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
        checkIfValid();
        sharedGroupManager.commitAndContinueAsRead();

        if (runAfterCommit != null)  {
            runAfterCommit.run();
        }

        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
            Handler handler = handlerIntegerEntry.getKey();
            String realmPath = handlerIntegerEntry.getValue();

            // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
            // file will make a commit in order to create the schema. Users should not be notified about that.
            if (!notifyLocalThread && handler.equals(this.handler)) {
                continue;
            }

            // For all other threads, use the Handler
            // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
            // as the target thread consumes messages at the same time. In this case it is not a problem as worst
            // case we end up with two REALM_CHANGED messages in the queue.
            if (
                    realmPath.equals(configuration.getPath())            // It's the right realm
                            && !handler.hasMessages(HandlerController.REALM_CHANGED)       // The right message
                            && handler.getLooper().getThread().isAlive() // The receiving thread is alive
                            && !handler.sendEmptyMessage(HandlerController.REALM_CHANGED)) {
                RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
                        "to prevent this.");
            }
        }
    }

