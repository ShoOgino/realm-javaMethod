    @SuppressFBWarnings("RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN")
    private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
        Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
        if (updatedRowKey.size() > 0) {
            WeakReference<RealmObjectProxy> realmObjectWeakReference = updatedRowKey.iterator().next();
            RealmObjectProxy proxy = realmObjectWeakReference.get();

            if (proxy != null) {
                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                int compare = callerVersionID.compareTo(result.versionID);
                // We always query on the same version.
                // Only two use cases could happen 1. We're on the same version or 2. The caller has advanced in the meanwhile.
                if (compare == 0) { // Same version import the handover.
                    long rowPointer = result.updatedRow.get(realmObjectWeakReference);
                    if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
                        // Cleanups a previously empty async RealmObject.
                        emptyAsyncRealmObject.remove(realmObjectWeakReference);
                        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
                    }
                    proxy.realmGet$proxyState().onCompleted$realm(rowPointer);
                    proxy.realmGet$proxyState().notifyChangeListeners$realm();

                } else if (compare > 0) {
                    // The caller has advanced we need to
                    // retry against the current version of the caller if it's still empty.
                    if (RealmObject.isValid(proxy)) { // Already completed & has a valid pointer no need to re-run.
                        if (RealmObject.isValid(proxy)) {
                            RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s], realm: %s. " +
                                            "RealmObject is already loaded, just notify it",
                                    realm, HandlerController.this);
                            proxy.realmGet$proxyState().notifyChangeListeners$realm();
                        }
                    } else {
                        RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s, realm: %s. " +
                                "RealmObject is not loaded yet. Rerun the query.",
                                proxy, HandlerController.this);
                        Object value = realmObjects.get(realmObjectWeakReference);
                        RealmQuery<? extends RealmModel> realmQuery;
                        if (value == null || value == NO_REALM_QUERY) { // This is a retry of an empty RealmObject.
                            realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);

                        } else {
                            realmQuery = (RealmQuery<? extends RealmModel>) value;
                        }

                        QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                .realmConfiguration(realm.getConfiguration())
                                .addObject(realmObjectWeakReference,
                                        realmQuery.handoverQueryPointer(),
                                        realmQuery.getArgument())
                                .sendToNotifier(realm.sharedRealm.realmNotifier,
                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
                                .build();

                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
                    }
                } else {
                    // Should not happen, since the the background thread position itself against the provided version
                    // and the caller thread can only go forward (advance_read).
                    throw new IllegalStateException("Caller thread behind the Worker thread");
                }
            } // else: Element GC'd in the meanwhile.
        }
    }

