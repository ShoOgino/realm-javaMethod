    private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
        Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
        if (updatedRowKey.size() > 0) {
            WeakReference<RealmObjectProxy> realmObjectWeakReference = updatedRowKey.iterator().next();
            RealmObjectProxy proxy = realmObjectWeakReference.get();

            if (proxy != null) {
                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
                int compare = callerVersionID.compareTo(result.versionID);
                // we always query on the same version
                // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
                if (compare == 0) { //same version import the handover
                    long rowPointer = result.updatedRow.get(realmObjectWeakReference);
                    if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
                        // cleanup a previously empty async RealmObject
                        emptyAsyncRealmObject.remove(realmObjectWeakReference);
                        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
                    }
                    proxy.realmGet$proxyState().onCompleted$realm(rowPointer);
                    proxy.realmGet$proxyState().notifyChangeListeners$realm();

                } else if (compare > 0) {
                    // the caller has advanced we need to
                    // retry against the current version of the caller if it's still empty
                    if (RealmObject.isValid(proxy)) { // already completed & has a valid pointer no need to re-run
                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
                                + " RealmObject is already loaded, just notify it.");
                        proxy.realmGet$proxyState().notifyChangeListeners$realm();

                    } else {
                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT " + proxy + "] , realm:" + HandlerController.this
                                + " RealmObject is not loaded yet. Rerun the query.");
                        Object value = realmObjects.get(realmObjectWeakReference);
                        RealmQuery<? extends RealmModel> realmQuery;
                        if (value == null || value == NO_REALM_QUERY) { // this is a retry of an empty RealmObject
                            realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);

                        } else {
                            realmQuery = (RealmQuery<? extends RealmModel>) value;
                        }

                        QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                .realmConfiguration(realm.getConfiguration())
                                .addObject(realmObjectWeakReference,
                                        realmQuery.handoverQueryPointer(),
                                        realmQuery.getArgument())
                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
                                .build();

                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
                    }
                } else {
                    // should not happen, since the the background thread position itself against the provided version
                    // and the caller thread can only go forward (advance_read)
                    throw new IllegalStateException("Caller thread behind the Worker thread");
                }
            } // else: element GC'd in the meanwhile
        }
    }

