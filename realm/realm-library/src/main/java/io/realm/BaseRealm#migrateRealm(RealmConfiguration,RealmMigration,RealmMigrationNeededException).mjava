    /**
     * Migrates the Realm file defined by the given configuration using the provided migration block.
     *
     * @param configuration configuration for the Realm that should be migrated. If this is a SyncConfiguration this
     * method does nothing.
     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
     * @param cause which triggers this migration.
     * @throws FileNotFoundException if the Realm file doesn't exist.
     * @throws IllegalArgumentException if the provided configuration is a {@link SyncConfiguration}.
     */
    protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
                                       final RealmMigrationNeededException cause)
            throws FileNotFoundException {

        if (configuration == null) {
            throw new IllegalArgumentException("RealmConfiguration must be provided");
        }
        if (configuration.isSyncConfiguration()) {
            throw new IllegalArgumentException("Manual migrations are not supported for synced Realms");
        }
        if (migration == null && configuration.getMigration() == null) {
            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
        }

        final AtomicBoolean fileNotFound = new AtomicBoolean(false);

        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
            @Override
            public void onResult(int count) {
                if (count != 0) {
                    throw new IllegalStateException("Cannot migrate a Realm file that is already open: "
                            + configuration.getPath());
                }

                File realmFile = new File(configuration.getPath());
                if (!realmFile.exists()) {
                    fileNotFound.set(true);
                    return;
                }

                DynamicRealm realm = null;
                RealmProxyMediator mediator = configuration.getSchemaMediator();
                OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
                try {
                    // Create a DynamicRealm WITHOUT putting it into a RealmCache to avoid recursive locks and call init
                    // steps multiple times (copy asset file / initialData transaction).
                    realm = DynamicRealm.createInstance(configuration);
                    realm.beginTransaction();
                    SharedRealm.MigrationCallback migrationCallback = null;
                    if (configuration.getMigration() != null) {
                        migrationCallback = new SharedRealm.MigrationCallback() {
                            @Override
                            public void onMigrationNeeded(SharedRealm sharedRealm, long oldVersion, long newVersion) {
                                configuration.getMigration().migrate(DynamicRealm.createInstance(sharedRealm),
                                        oldVersion, newVersion);
                            }
                        };
                    }
                    realm.sharedRealm.updateSchema(schemaInfo, configuration.getSchemaVersion(), migrationCallback);
                    realm.commitTransaction();
                } catch (RuntimeException e) {
                    if (realm != null) {
                        realm.cancelTransaction();
                    }
                    throw e;
                } finally {
                    if (realm != null) {
                        realm.close();
                    }
                }
            }
        });

        if (fileNotFound.get()) {
            throw new FileNotFoundException("Cannot migrate a Realm file which doesn't exist: "
                    + configuration.getPath());
        }
    }

