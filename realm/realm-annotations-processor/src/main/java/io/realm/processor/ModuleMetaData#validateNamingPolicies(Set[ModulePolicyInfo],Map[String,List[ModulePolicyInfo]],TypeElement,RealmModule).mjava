    /**
     * Validates that the class/field naming policy for this module is correct.
     *
     * @param globalModuleInfo list of all modules with `allClasses` set
     * @param classSpecificModuleInfo map of explicit classes and which modules they are explicitly mentioned in.
     * @param classElement class element currently being validated
     * @param moduleAnnotation annotation on this class.
     * @return {@code true} if everything checks out, {@code false} if an error was found and reported.
     */
    private boolean validateNamingPolicies(Set<ModulePolicyInfo> globalModuleInfo, Map<String, List<ModulePolicyInfo>> classSpecificModuleInfo, TypeElement classElement, RealmModule moduleAnnotation) {
        RealmNamingPolicy classNamePolicy = moduleAnnotation.classNamingPolicy();
        RealmNamingPolicy fieldNamePolicy = moduleAnnotation.fieldNamingPolicy();
        String qualifiedModuleClassName = classElement.getQualifiedName().toString();
        ModulePolicyInfo moduleInfo = new ModulePolicyInfo(qualifiedModuleClassName, classNamePolicy, fieldNamePolicy);

        // The difference between `allClasses` and a list of classes is a bit tricky at this stage
        // as we haven't processed the full list of classes yet. We therefore need to treat
        // each case specifically :(
        // We do not compare against the default module as it is always configured correctly
        // with NO_POLICY, meaning it will not trigger any errors.
        if (moduleAnnotation.allClasses()) {
            // Check for conflicts with all other modules with `allClasses` set.
            for (ModulePolicyInfo otherModuleInfo : globalModuleInfo) {
                if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
                    return false;
                }
            }

            // Check for conflicts with specifically named classes. This can happen if another
            // module is listing specific classes with another policy.
            for (Map.Entry<String, List<ModulePolicyInfo>> classPolicyInfo : classSpecificModuleInfo.entrySet()) {
                for (ModulePolicyInfo otherModuleInfo : classPolicyInfo.getValue()) {
                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
                        return false;
                    }
                }
            }

            // Everything checks out. Add moduleInfo so we can track it for the next module.
            globalModuleInfo.add(moduleInfo);
            globalModules.add(qualifiedModuleClassName);

        } else {
            // We need to verify each class in the modules class list
            Set<String> classNames = getClassListFromModule(classElement);
            for (String qualifiedClassName : classNames) {

                // Check that no other module with `allClasses` conflict with this specific
                // class configuration
                for (ModulePolicyInfo otherModuleInfo : globalModuleInfo) {
                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
                        return false;
                    }
                }

                // Check that this specific class isn't conflicting with another module
                // specifically mentioning it using `classes = { ... }`
                List<ModulePolicyInfo> otherModules = classSpecificModuleInfo.get(qualifiedClassName);
                if (otherModules != null) {
                    for (ModulePolicyInfo otherModuleInfo : otherModules) {
                        if (checkAndReportPolicyConflict(qualifiedClassName, moduleInfo, otherModuleInfo)) {
                            return false;
                        }
                    }
                }

                // Keep track of the specific class for other module checks. We only
                // need to track the latest module seen as previous errors would have been
                // caught in a previous iteration of the loop.
                if (!classSpecificModuleInfo.containsKey(qualifiedClassName)) {
                    classSpecificModuleInfo.put(qualifiedClassName, new ArrayList<>());
                }
                classSpecificModuleInfo.get(qualifiedClassName).add(moduleInfo);
            }
            specificClassesModules.put(qualifiedModuleClassName, classNames);
        }

        classNamingPolicy.put(qualifiedModuleClassName, classNamePolicy);
        fieldNamingPolicy.put(qualifiedModuleClassName, fieldNamePolicy);
        return true;
    }

