    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "createExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers

        // Guess capacity for Arrays used by OsObjectSchemaInfo.
        // Used to prevent array resizing at runtime
        int persistedFields = metadata.getFields().size();
        int computedFields = metadata.getBacklinkFields().size();

        writer.emitStatement(
                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)",
                internalClassName, persistedFields, computedFields);

        // For each field generate corresponding table index constant
        for (RealmFieldElement field : metadata.getFields()) {
            String fieldName = field.getInternalFieldName();

            Constants.RealmFieldType fieldType = getRealmTypeChecked(field);
            switch (fieldType) {
                case NOTYPE: {
                    // Perhaps this should fail quickly?
                    break;
                }
                case OBJECT: {
                    String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
                    String internalClassName = Utils.getReferencedTypeInternalClassNameStatement(fieldTypeQualifiedName, classCollection);
                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, %s)",
                            fieldName, internalClassName);
                    break;
                }
                case LIST: {
                    String genericTypeQualifiedName = Utils.getGenericTypeQualifiedName(field);
                    String internalClassName = Utils.getReferencedTypeInternalClassNameStatement(genericTypeQualifiedName, classCollection);
                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, %s)",
                            fieldName, internalClassName);
                    break;
                }
                case INTEGER_LIST:
                case BOOLEAN_LIST:
                case STRING_LIST:
                case BINARY_LIST:
                case DATE_LIST:
                case FLOAT_LIST:
                case DOUBLE_LIST:
                    writer.emitStatement("builder.addPersistedValueListProperty(\"%s\", %s, %s)",
                            fieldName, fieldType.getRealmType(), metadata.isElementNullable(field) ? "!Property.REQUIRED" : "Property.REQUIRED");
                    break;

                case BACKLINK:
                    throw new IllegalArgumentException("LinkingObject field should not be added to metadata");

                case INTEGER:
                case FLOAT:
                case DOUBLE:
                case BOOLEAN:
                case STRING:
                case DATE:
                case BINARY:
                case REALM_INTEGER:
                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
                    writer.emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)",
                            fieldName,
                            fieldType.getRealmType(),
                            primaryKeyFlag,
                            indexedFlag,
                            nullableFlag);
                    break;

                default:
                    throw new IllegalArgumentException("'fieldType' " + fieldName + " is not handled");
            }
        }
        for (Backlink backlink: metadata.getBacklinkFields()) {
            // Backlinks can only be created between classes in the current round of annotation processing
            // as the forward link cannot be created unless you know the type already.
            ClassMetaData sourceClass = classCollection.getClassFromQualifiedName(backlink.getSourceClass());
            String targetField = backlink.getTargetField(); // Only in the model, so no internal name exists
            String internalSourceField = sourceClass.getInternalFieldName(backlink.getSourceField());
            writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
                    targetField, sourceClass.getInternalClassName(), internalSourceField);
        }
        writer.emitStatement("return builder.build()");
        writer.endMethod()
                .emitEmptyLine();
    }

