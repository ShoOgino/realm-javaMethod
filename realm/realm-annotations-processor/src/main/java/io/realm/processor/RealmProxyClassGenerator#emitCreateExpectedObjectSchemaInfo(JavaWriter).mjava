    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "createExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers

        // Guess capacity for Arrays used by OsObjectSchemaInfo.
        // Used to prevent array resizing at runtime
        int persistedFields = metadata.getFields().size();
        int computedFields = metadata.getBacklinkFields().size();

        writer.emitStatement(
                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)",
                this.simpleClassName, persistedFields, computedFields);

        // For each field generate corresponding table index constant
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();

            Constants.RealmFieldType fieldType = getRealmTypeChecked(field);
            switch (fieldType) {
                case NOTYPE:
                    // Perhaps this should fail quickly?
                    break;

                case OBJECT:
                    String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
                            fieldName, fieldTypeSimpleName);
                    break;

                case LIST:
                    // only for model list.
                    String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
                            fieldName, genericTypeSimpleName);
                    break;

                case INTEGER_LIST:
                case BOOLEAN_LIST:
                case STRING_LIST:
                case BINARY_LIST:
                case DATE_LIST:
                case FLOAT_LIST:
                case DOUBLE_LIST:
                    writer.emitStatement("builder.addPersistedValueListProperty(\"%s\", %s, %s)",
                            fieldName, fieldType.getRealmType(), metadata.isElementNullable(field) ? "!Property.REQUIRED" : "Property.REQUIRED");
                    break;

                case BACKLINK:
                    throw new IllegalArgumentException("LinkingObject field should not be added to metadata");

                case INTEGER:
                case FLOAT:
                case DOUBLE:
                case BOOLEAN:
                case STRING:
                case DATE:
                case BINARY:
                case REALM_INTEGER:
                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
                    writer.emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)",
                            fieldName,
                            fieldType.getRealmType(),
                            primaryKeyFlag,
                            indexedFlag,
                            nullableFlag);
                    break;

                default:
                    throw new IllegalArgumentException("'fieldType' " + fieldName + " is not handled");
            }
        }
        for (Backlink backlink: metadata.getBacklinkFields()) {
            writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
                    backlink.getTargetField(), backlink.getSimpleSourceClass(), backlink.getSourceField());
        }
        writer.emitStatement("return builder.build()");
        writer.endMethod()
                .emitEmptyLine();
    }

