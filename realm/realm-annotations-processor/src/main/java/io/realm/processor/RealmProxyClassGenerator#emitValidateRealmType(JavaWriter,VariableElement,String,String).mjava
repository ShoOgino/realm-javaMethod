    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
            throws IOException {

        // make sure types align
        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
                "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
                "\")", fieldName);
        writer.endControlFlow();
        writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
                fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s' in existing Realm file.\")",
                Utils.getFieldTypeSimpleName(field), fieldName);
        writer.endControlFlow();

        // make sure that nullability matches
        if (metadata.isNullable(field)) {
            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
            if (metadata.isPrimaryKey(field)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                        fieldName);
                // nullability check for boxed types
            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"Field '%s' does not support null values in the existing Realm file. " +
                                "Either set @Required, use the primitive type for field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' is required. Either set @Required to field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        } else {
            // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
            if (metadata.isPrimaryKey(field)) {
                writer
                        .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != Table.NO_MATCH)",
                                fieldIndexVariableReference(field), fieldIndexVariableReference(field))
                        .emitStatement("throw new IllegalStateException(\"Cannot migrate an object with null value in field '%s'." +
                                        " Either maintain the same type for primary key field '%s', or remove the object with null value before migration.\")",
                                fieldName, fieldName)
                        .endControlFlow();
            } else {
                writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
                if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                    " \"Field '%s' does support null values in the existing Realm file. " +
                                    "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                            fieldName, fieldName);
                } else {
                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                    " \"Field '%s' does support null values in the existing Realm file. " +
                                    "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                            fieldName, fieldName);
                }
                writer.endControlFlow();
            }
        }

        // Validate @Index
        if (metadata.getIndexedFields().contains(field)) {
            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
            writer.endControlFlow();
        }
    }

