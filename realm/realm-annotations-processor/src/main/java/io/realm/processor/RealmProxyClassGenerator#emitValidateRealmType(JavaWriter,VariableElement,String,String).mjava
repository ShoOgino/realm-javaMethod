    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
            throws IOException {

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", %s, \"%s\")",
                fieldName, getRealmTypeChecked(field).getRealmType(), Utils.getFieldTypeSimpleName(field));

        // make sure that nullability matches
        if (!metadata.isNullable(field)) {
            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        } else {
            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
            if (metadata.isPrimaryKey(field)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                        fieldName);
                // nullability check for boxed types
            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"Field '%s' does not support null values in the existing Realm file. " +
                                "Either set @Required, use the primitive type for field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' is required. Either set @Required to field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        }

        // Validate @Index
        if (metadata.getIndexedFields().contains(field)) {
            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
            writer.endControlFlow();
        }
    }

