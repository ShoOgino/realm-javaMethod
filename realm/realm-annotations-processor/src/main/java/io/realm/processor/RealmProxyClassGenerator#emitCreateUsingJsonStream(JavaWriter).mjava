    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
    // instead of createObject() to avoid parsing the stream twice.
    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
        writer.beginMethod(
                qualifiedClassName,
                "createUsingJsonStream",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                Collections.singletonList("IOException"));

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("boolean jsonHasPrimaryKey = false");
        }
        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        writer.emitStatement("reader.beginObject()");
        writer.beginControlFlow("while (reader.hasNext())");
        writer.emitStatement("String name = reader.nextName()");
        writer.beginControlFlow("if (false)");
        Collection<VariableElement> fields = metadata.getFields();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);

            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListFromStream(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            } else {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.nextControlFlow("else");
        writer.emitStatement("reader.skipValue()");
        writer.endControlFlow();

        writer.endControlFlow();
        writer.emitStatement("reader.endObject()");

        if (metadata.hasPrimaryKey()) {
            writer.beginControlFlow("if (!jsonHasPrimaryKey)")
                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey())
                    .endControlFlow();
        }

        writer.emitStatement("return realm.copyToRealm(obj)");
        writer.endMethod();
        writer.emitEmptyLine();
    }

