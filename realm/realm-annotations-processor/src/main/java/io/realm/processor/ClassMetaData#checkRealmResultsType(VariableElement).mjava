    private boolean checkRealmResultsType(VariableElement field) {
        // Only classes implementing RealmModel are allowed since RealmResults field is used only for backlinks.

        // Check for missing generic (default back to Object)
        if (Utils.getGenericTypeQualifiedName(field) == null) {
            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field);
            return false;
        }

        TypeMirror fieldType = field.asType();
        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class or interface*/) {
            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
                Utils.error(
                        "Only concrete Realm classes are allowed in RealmResults. "
                                + "Neither interfaces nor abstract classes are allowed.",
                        field);
                return false;
            }
        }

        // Check if the actual value class is acceptable
        if (!Utils.isRealmModel(elementTypeMirror)) {
            Utils.error(getFieldErrorSuffix(field) + "Element type of RealmResults must be a class implementing 'RealmModel'.", field);
            return false;
        }

        return true;
    }

