    private boolean checkRealmListType(VariableElement field) {
        // Check for missing generic (default back to Object)
        if (Utils.getGenericTypeQualifiedName(field) == null) {
            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field);
            return false;
        }

        // Check that the referenced type is a concrete class and not an interface
        TypeMirror fieldType = field.asType();
        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class of interface*/) {
            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
                Utils.error(
                        getFieldErrorSuffix(field) + "Only concrete Realm classes are allowed in RealmLists. "
                                + "Neither interfaces nor abstract classes are allowed.",
                        field);
                return false;
            }
        }

        // Check if the actual value class is acceptable
        if (!containsType(validListValueTypes, elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
            final StringBuilder messageBuilder = new StringBuilder(
                    getFieldErrorSuffix(field) + "Element type of RealmList must be a class implementing 'RealmModel' or one of ");
            final String separator = ", ";
            for (TypeMirror type : validListValueTypes) {
                messageBuilder.append('\'').append(type.toString()).append('\'').append(separator);
            }
            messageBuilder.setLength(messageBuilder.length() - separator.length());
            messageBuilder.append('.');
            Utils.error(messageBuilder.toString(), field);
            return false;
        }

        return true;
    }

