    private boolean categorizeField(Element element) {
        VariableElement fieldRef = (VariableElement) element;

        // completely ignore any static fields
        if (fieldRef.getModifiers().contains(Modifier.STATIC)) { return true; }

        // Ignore fields marked with @Ignore or if they are transient
        if (fieldRef.getAnnotation(Ignore.class) != null || fieldRef.getModifiers().contains(Modifier.TRANSIENT)) {
            return true;
        }

        // Determine name for field
        String internalFieldName = getInternalFieldName(fieldRef, defaultFieldNameFormatter);
        RealmFieldElement field = new RealmFieldElement(fieldRef, internalFieldName);

        if (field.getAnnotation(Index.class) != null) {
            if (!categorizeIndexField(element, field)) { return false; }
        }

        // @Required annotation of RealmList field only affects its value type, not field itself.
        if (Utils.isRealmList(field)) {
            boolean hasRequiredAnnotation = hasRequiredAnnotation(field);
            final List<? extends TypeMirror> listGenericType = ((DeclaredType) field.asType()).getTypeArguments();
            boolean containsRealmModelClasses = (!listGenericType.isEmpty() && Utils.isRealmModel(listGenericType.get(0)));

            // @Required not allowed if the list contains Realm model classes
            if (hasRequiredAnnotation && containsRealmModelClasses) {
                Utils.error("@Required not allowed on RealmList's that contain other Realm model classes.");
                return false;
            }

            // @Required thus only makes sense for RealmLists with primitive types
            // We only check @Required annotation. @org.jetbrains.annotations.NotNull annotation should not affect nullability of the list values.
            if (!hasRequiredAnnotation) {
                if (!containsRealmModelClasses) {
                    nullableValueListFields.add(field);
                }
            }
        } else if (isRequiredField(field)) {
            if (!checkBasicRequiredAnnotationUsage(element, field)) {
                return false;
            }
        } else {
            // The field doesn't have the @Required and @org.jetbrains.annotations.NotNull annotation.
            // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
            // nullableFields.
            // RealmList of models, RealmResults(backlinks) and primitive types are NOT nullable. @Required annotation is not supported.
            if (!Utils.isPrimitiveType(field) && !Utils.isRealmResults(field)) {
                nullableFields.add(field);
            }
        }

        if (field.getAnnotation(PrimaryKey.class) != null) {
            if (!categorizePrimaryKeyField(field)) { return false; }
        }

        // @LinkingObjects cannot be @PrimaryKey or @Index.
        if (field.getAnnotation(LinkingObjects.class) != null) {
            // Do not add backlinks to fields list.
            return categorizeBacklinkField(field);
        }

        // Similarly, a MutableRealmInteger cannot be a @PrimaryKey or @LinkingObject.
        if (Utils.isMutableRealmInteger(field)) {
            if (!categorizeMutableRealmIntegerField(field)) { return false; }
        }

        // Standard field that appears to be valid (more fine grained checks might fail later).
        fields.add(field);

        return true;
    }

