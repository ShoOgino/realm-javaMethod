    private boolean categorizeField(Element element) {
        VariableElement field = (VariableElement) element;

        // completely ignore any static fields
        if (field.getModifiers().contains(Modifier.STATIC)) { return true; }

        // Ignore fields marked with @Ignore or if they are transient
        if (field.getAnnotation(Ignore.class) != null || field.getModifiers().contains(Modifier.TRANSIENT)) {
            return true;
        }

        if (field.getAnnotation(Index.class) != null) {
            if (!categorizeIndexField(element, field)) { return false; }
        }

        if (isRequiredField(field)) {
            categorizeRequiredField(element, field);
        } else {
            // The field doesn't have the @Required annotation.
            // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
            // nullableFields.
            // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
            if (!Utils.isPrimitiveType(field) && !Utils.isRealmList(field)) {
                nullableFields.add(field);
            }
        }

        if (field.getAnnotation(PrimaryKey.class) != null) {
            if (!categorizePrimaryKeyField(field)) { return false; }
        }

        // @LinkingObjects cannot be @PrimaryKey or @Index.
        if (field.getAnnotation(LinkingObjects.class) != null) {
            // Do not add backlinks to fields list.
            return categorizeBacklinkField(field);
        }

        // Similarly, a MutableRealmInteger cannot be a @PrimaryKey or @LinkingObject.
        if (Utils.isMutableRealmInteger(field)) {
            if (!categorizeMutableRealmIntegerField(field)) { return false; }
        }

        // Standard field that appears to be valid (more fine grained checks might fail later).
        fields.add(field);

        return true;
    }

