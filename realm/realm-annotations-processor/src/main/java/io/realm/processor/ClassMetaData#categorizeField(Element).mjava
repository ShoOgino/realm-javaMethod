    private boolean categorizeField(Element element) {
        VariableElement field = (VariableElement) element;

        // completely ignore any static fields
        if (field.getModifiers().contains(Modifier.STATIC)) { return true; }

        // Ignore fields marked with @Ignore or if they are transient
        if (field.getAnnotation(Ignore.class) != null || field.getModifiers().contains(Modifier.TRANSIENT)) {
            return true;
        }

        if (field.getAnnotation(Index.class) != null) {
            if (!categorizeIndexField(element, field)) { return false; }
        }

        if (field.getAnnotation(Required.class) != null) {
            categorizeRequiredField(element, field);
        } else {
            // The field doesn't have the @Required annotation.
            // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
            // nullableFields.
            // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
            if (!Utils.isPrimitiveType(field) && !Utils.isRealmList(field)) {
                nullableFields.add(field);
            }
        }

        if (field.getAnnotation(PrimaryKey.class) != null) {
            if (!categorizePrimaryKeyField(field)) { return false; }
        }

        // Check @LinkingObjects last since it is not allowed to be either @Index, @Required or @PrimaryKey
        if (field.getAnnotation(LinkingObjects.class) != null) {
            return categorizeBacklinkField(field);
        }

        // Standard field that appear valid (more fine grained checks might fail later).
        fields.add(field);

        return true;
    }

