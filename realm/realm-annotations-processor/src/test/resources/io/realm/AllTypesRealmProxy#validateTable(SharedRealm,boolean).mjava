    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
        }
        Table table = sharedRealm.getTable("class_AllTypes");
        final long columnCount = table.getColumnCount();
        if (columnCount != 9) {
            if (columnCount < 9) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
            }
            if (allowExtraColumns) {
                RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
            } else {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
            }
        }
        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
        for (long i = 0; i < columnCount; i++) {
            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
        }

        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm, table);

        if (!table.hasPrimaryKey()) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
        } else {
            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
            }
        }

        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnString", RealmFieldType.STRING, "String");
        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
        }
        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnLong", RealmFieldType.INTEGER, "long");
        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnFloat", RealmFieldType.FLOAT, "float");
        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDouble", RealmFieldType.DOUBLE, "double");
        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBoolean", RealmFieldType.BOOLEAN, "boolean");
        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDate", RealmFieldType.DATE, "Date");
        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBinary", RealmFieldType.BINARY, "byte[]");
        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
        }
        Table table_7 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
        }
        Table table_8 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
        }

        long backlinkFieldIndex;
        Table backlinkSourceTable;
        Table backlinkTargetTable;
        RealmFieldType backlinkFieldType;
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
        if (backlinkFieldIndex == Table.NO_MATCH) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
        }
        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
        if (!table.hasSameSchema(backlinkTargetTable)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
        }

        return columnInfo;
    }

