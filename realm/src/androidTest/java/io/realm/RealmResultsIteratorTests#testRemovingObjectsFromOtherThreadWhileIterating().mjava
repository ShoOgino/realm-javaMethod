    // Using size() as heuristic for concurrent modifications is dangerous as we might skip
    // elements.
    public void testRemovingObjectsFromOtherThreadWhileIterating() throws InterruptedException, ExecutionException {

        // Prefill
        Realm realm = Realm.getInstance(getContext(), "test");
        realm.beginTransaction();
        realm.clear(AllTypes.class);
        AllTypes o1 = realm.createObject(AllTypes.class);
        o1.setColumnLong(1);
        AllTypes o2 = realm.createObject(AllTypes.class);
        o2.setColumnLong(2);
        realm.commitTransaction();

        // Iterate past 1st item
        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
        Iterator<AllTypes> it = result.iterator();
        it.next();

        // Delete first item and insert new. Meaning Item 2 gets Item 1s place, and is skipped
        // in iterator when calling next().
        Callable<Boolean> backgroundWorker = new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                Realm backgroundRealm = Realm.getInstance(getContext(), "test", false);
                backgroundRealm.beginTransaction();
                RealmResults<AllTypes> backgroundResult = backgroundRealm.allObjects(AllTypes.class);
                if (backgroundResult.size() != 2) return false;
                backgroundResult.sort("columnLong", RealmResults.SORT_ORDER_ASCENDING).remove(0);
                AllTypes o3 = backgroundRealm.createObject(AllTypes.class);
                o3.setColumnLong(3);
                backgroundRealm.commitTransaction();
                if (backgroundResult.size() != 2) return false;
                return true;
            }
        };

        // Wait for background thread to finish
        ExecutorService executorService = Executors.newFixedThreadPool(1);
        Future<Boolean> backgroundResult = executorService.submit(backgroundWorker);
        assertTrue(backgroundResult.get());
        realm.refresh(); // This shouldn't be needed, but is currently.

        // Next item would now be o3.
        try {
            AllTypes o3 = it.next();
            assertEquals(3, o3.getColumnLong());
            fail("Failed to detect the list was modified, but retained it's size while iterating");
        } catch (ConcurrentModificationException ignored) {
            return;
        }
    }

