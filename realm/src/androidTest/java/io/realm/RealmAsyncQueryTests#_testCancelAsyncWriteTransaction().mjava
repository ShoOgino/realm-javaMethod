    public void _testCancelAsyncWriteTransaction() throws Throwable {
        final CountDownLatch signalTransactionStarted = new CountDownLatch(1);
        final Looper[] looper = new Looper[1];
        final Realm[] realm = new Realm[1];
        final RealmQuery.Request[] request = new RealmQuery.Request[1];
        final Throwable[] threadAssertionError = new Throwable[1];
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                Looper.prepare();
                looper[0] = Looper.myLooper();
                try {
                    realm[0] = openRealmInstance("test_cancel_async_write_transaction");
                    request[0] = realm[0].executeTransaction(new Realm.Transaction() {
                        @Override
                        public void execute(Realm realm) {
                            signalTransactionStarted.countDown();
                            for (int i = 0; i < 10000; i++) {
                                Owner owner = realm.createObject(Owner.class);
                                owner.setName("Owner " + i);
                            }
                            SystemClock.sleep(100);

                        }
                    }, new Realm.Transaction.Callback() {
                        @Override
                        public void onSuccess() {
                            threadAssertionError[0] = new AssertionFailedError("Transaction should not be completed");
                        }

                        @Override
                        public void onError(Throwable e) {
                            threadAssertionError[0] = new AssertionFailedError("Transaction should not call onError");
                            e.printStackTrace();
                        }
                    });

                    Looper.loop();

                } catch (Exception e) {
                    e.printStackTrace();
                    threadAssertionError[0] = e;

                } finally {
                    if (signalTransactionStarted.getCount() > 0) {
                        signalTransactionStarted.countDown();
                    }
                    if (realm.length > 0 && realm[0] != null) {
                        realm[0].close();
                    }
                }
            }
        });

        // wait until the async transaction starts
        signalTransactionStarted.await();
        request[0].cancel();
        executorService.shutdown();
        executorService.awaitTermination(5, TimeUnit.SECONDS);

        assertTrue(request[0].isCancelled());
        // nothing was committed
        Realm ownerRealm = Realm.getInstance(realm[0].getConfiguration());
        assertEquals(0, ownerRealm.allObjects(Owner.class).size());
        ownerRealm.close();

        looper[0].quit();
        executorService.shutdownNow();
        if (null != threadAssertionError[0]) {
            // throw any assertion errors happened in the background thread
            throw threadAssertionError[0];
        }
    }

