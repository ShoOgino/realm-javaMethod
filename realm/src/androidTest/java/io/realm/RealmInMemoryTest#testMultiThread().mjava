    // Test below scenario:
    // 1. Create a in-memory Realm instance in the main thread.
    // 2. Create a in-memory Realm with same name in another thread.
    // 3. Close the in-memory Realm instance in the main thread and the Realm data should not be released since
    //    another instance is still held by the other thread.
    // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
    //    specific name exists.
    public void testMultiThread() throws InterruptedException, ExecutionException {
        final CountDownLatch workerReadyLatch = new CountDownLatch(1);
        final CountDownLatch workerFinishedLatch = new CountDownLatch(1);
        final CountDownLatch realmInMainClosedLatch = new CountDownLatch(1);
        final AssertionFailedError threadError[] = new AssertionFailedError[1];

        // Step 2.
        Thread workerThread = new Thread(new Runnable() {
            @Override
            public void run() {
                Realm realm = Realm.getInstance(inMemConf);
                realm.beginTransaction();
                Dog dog = realm.createObject(Dog.class);
                dog.setName("DinoDog");
                realm.commitTransaction();

                try {
                    assertEquals(realm.allObjects(Dog.class).size(), 1);
                } catch (AssertionFailedError afe) {
                    threadError[0] = afe;
                    realm.close();
                    return;
                }
                workerReadyLatch.countDown();

                // Wait until Realm instance closed in main thread
                try {
                    realmInMainClosedLatch.await(3, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    threadError[0] = new AssertionFailedError("Worker thread was interrupted.");
                    realm.close();
                    return;
                }

                realm.close();
                workerFinishedLatch.countDown();
            }
        });
        workerThread.start();


        // Wait until the worker thread started
        workerReadyLatch.await(3, TimeUnit.SECONDS);
        if (threadError[0] != null) { throw threadError[0]; }

        // refresh will be ran in the next loop, manually refresh it here.
        testRealm.refresh();
        assertEquals(testRealm.allObjects(Dog.class).size(), 1);

        // Step 3.
        // Release the main thread Realm reference, and the worker thread hold the reference still
        testRealm.close();

        // Step 4.
        // Create a new Realm reference in main thread and checking the data.
        testRealm = Realm.getInstance(inMemConf);
        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
        testRealm.close();

        // Let the worker thread continue.
        realmInMainClosedLatch.countDown();

        // Wait until the worker thread finished
        workerFinishedLatch.await(3, TimeUnit.SECONDS);
        if (threadError[0] != null) { throw threadError[0]; }

        // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance
        testRealm = Realm.getInstance(inMemConf);
        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
    }

