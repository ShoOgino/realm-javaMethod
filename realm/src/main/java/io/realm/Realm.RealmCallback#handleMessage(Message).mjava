        @Override
        public boolean handleMessage(Message message) {
            switch (message.what) {
                case REALM_CHANGED: {
//                    System.out.println("REALM_CHANGED");
                    if (threadContainsAsyncQueries()) {
                        if (updateAsyncQueries != null && !updateAsyncQueries.isDone()) {
                            // try to cancel any pending update since we're submitting a new one anyway
                            updateAsyncQueries.cancel(true);
                            RealmLog.d("REALM_CHANGED cancelling pending REALM_UPDATE_ASYNC_QUERIES updates");
                        }
                        // prepare the list of RealmResults + Table query to be exported
                        // need to keep a weak reference (when delivering onSuccess) to
                        // RealmResults + RealmQuery (to export again the query)

                        // [STEP: 1] submit a job to a scheduler & as a parameter use current handler
                        // #getHandler() + list of exported queries to be re-run
                        ArrayList<UpdateAsyncQueriesTask.Entry> queriesToUpdate = new ArrayList<UpdateAsyncQueriesTask.Entry>();
                        Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator = asyncQueries.get().entrySet().iterator();
                        while (iterator.hasNext()) {
                            Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>> entry = iterator.next();
                            // need to call via shared_group to export the query
                            //TODO provoke a null on realmResults to see how remove behave
                            WeakReference<RealmResults<?>> weakReference = entry.getKey();
                            RealmResults<?> realmResults = weakReference.get();
                            if (realmResults == null) {
                                iterator.remove();
//                                asyncQueries.get().remove(weakReference);
                            }

//                            Integer identityHash = System.identityHashCode(realmResults);
//                            hashToInstance.put(identityHash, new WeakReference<RealmResults<?>>(realmResults));

                            // Note: we're passing an WeakRef of a RealmResults to another thread
                            //       this is safe as long as we don't invoke any of RealmResults methods.
                            //       we're just using it as a Key in an IdentityHashMap (i.e doesn't call
                            //       AbstractList's hashCode, that require accessing objects from another thread)
                            //
                            //       watch out when you debug, as you're IDE try to evaluate RealmResults
                            //       which break the Thread confinement constraints.
                            queriesToUpdate.add(UpdateAsyncQueriesTask.Entry.newRealmResultsEntry(weakReference,
                                    new UpdateAsyncQueriesTask
                                            .UpdateQuery(entry.getValue().handoverQueryPointer(sharedGroup.getNativePointer()),
                                            entry.getValue().getArgument())));
                        }

                        RealmLog.d("REALM_CHANGED updating " + queriesToUpdate.size() + " async queries");
//                        Runnable task = new UpdateAsyncQueriesTask(getHandler(), getConfiguration(), queriesToUpdate, sharedGroup.getVersion());
                        Runnable task = new UpdateAsyncQueriesTask(handler, getConfiguration(), REALM_UPDATE_ASYNC_QUERIES, queriesToUpdate, sharedGroup.getVersion());
                        updateAsyncQueries = asyncQueryExecutor.submit(task);
                        // submit a runnbal UpdateTask to the same pool as regular queries
                        // maybe have a method inside RealmQuery#update since it has all the information
                        // or create a new Callable object that has all the parameters & return a Future<List<[RR-TV]> + version
                        // this Future could be cancelled if the task is pending & we receive a new REALM_CHANGED in the mean time
                        // since we already have a new version of Realm.
                        // this leans to a Worker thread caching it's Realm in a ThreadLocal (to be reused)
                        // since all queries need to target the same version (Bg thread need to receive a version Id
                        // (from UI Thread) in order to import correctly the query. then update everyone the deliver
                        // this could be done by providing a ThreadFactory (but watch out- since you need to detect corectly
                        // the destruction of this thread in order to close the Realm)


                    } else {
                        RealmLog.d("REALM_CHANGED no async queries, advance_read");
                        transaction.advanceRead();
                        sendNotifications();
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_QUERY: {
//                    System.out.println("REALM_COMPLETED_ASYNC_QUERY");
                    //TODO: need to add a check in case the user forced the query to be syn by calling load
                    // in this case a hashCode compare will allow us to avoid any rerun (or import) logic
                    // should aim to ignore

                    // One async query has completed
                    UpdateAsyncQueriesTask.Result result
                            = (UpdateAsyncQueriesTask.Result) message.obj;
                    //TODO assert result should contain at least one weak RR
                    WeakReference<RealmResults<?>> weakRealmResults = (WeakReference<RealmResults<?>>) result.updatedTableViews.keySet().toArray()[0];
                    RealmResults<?> realmResults = weakRealmResults.get();
                    if (realmResults == null) {
                        asyncQueries.get().remove(weakRealmResults);
                        RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] RealmResults GC'd ignore results");

                    } else {
                        SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                        int compare = callerVersionID.compareTo(result.versionID);
                        if (compare == 0) {
                            // if the RealmResults is empty (has not completed yet) then use the value
                            // otherwise a task (grouped update) has already updated this RealmResults
                            if (!realmResults.isLoaded()) {
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , same versions, using results (RealmResults is not loaded)");
                                // swap pointer
                                realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                                // notify callbacks
                                realmResults.notifyChangeListeners();
                            } else {
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , ignoring result the RealmResults (is already loaded)");
                            }

                        } else if (compare > 0) {
                            // we have two use cases:
                            // 1- this RealmResults is not empty, this means that after we started the async
                            //    query, we received a REALM_CHANGE that triggered an update of all async queries
                            //    including the last async submitted, so no need to use the provided TableView pointer
                            //    (or the user forced the sync behaviour .load())
                            // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread
                            //    this could happen if the current thread advanced the shared_group (via a write or refresh)
                            //    this means that we need to rerun the query against a newer worker thread.

                            if (!realmResults.isLoaded()) { // UC2
                                // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");
                                ArrayList<UpdateAsyncQueriesTask.Entry> queriesToUpdate = new ArrayList<UpdateAsyncQueriesTask.Entry>(1);
                                RealmQuery<?> query = asyncQueries.get().get(weakRealmResults);
                                queriesToUpdate.add(UpdateAsyncQueriesTask.Entry.newRealmResultsEntry(weakRealmResults,
                                        new UpdateAsyncQueriesTask
                                                .UpdateQuery(query.handoverQueryPointer(sharedGroup.getNativePointer()),
                                                query.getArgument())));

                                Runnable task = new UpdateAsyncQueriesTask(handler, getConfiguration(), REALM_COMPLETED_ASYNC_QUERY, queriesToUpdate, sharedGroup.getVersion());
                                updateAsyncQueries = asyncQueryExecutor.submit(task);

                            } else {
                                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , caller is more advanced & RealmResults is loaded ignore the outdated result");
                            }

                        } else {
                            // The caller thread is behind the worker thread,
                            // no need to rerun the query, since we're going to receive the update signal
                            // & batch update all async queries including this one
                            // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                            RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
                        }
                    }
                    break;
                }
                case REALM_UPDATE_ASYNC_QUERIES: {
//                    System.out.println("REALM_UPDATE_ASYNC_QUERIES");
                    // This is called once the background thread completed the update of the queries
                    // edge case: if a query has been add (to the caller thread) while the background thread
                    // was busy updating the queries the submit again [STEP: 1]
                    // this check could be achieved by checking that all live (non GC'd) instance of async RealmResults
                    // are present within the response from the worker thread. so advance_read is safe to adavnce
                    // without a risk of advancing a missed query not updated (or RR without TV pointer)


                    UpdateAsyncQueriesTask.Result result
                            = (UpdateAsyncQueriesTask.Result) message.obj;

                    // the advance_read to the background.shared_group_version or latest?
                    // we need to receive version + be able to advance_read to a specific version
                    SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();

                    int compare = callerVersionID.compareTo(result.versionID);

                    if (compare > 0) {

                        RealmLog.d("REALM_UPDATE_ASYNC_QUERIES caller is more advanced, rerun updates");
                        // The caller is more advance than the updated queries ==>
                        // need to refresh them again (if there is still queries)
                        handler.sendEmptyMessage(REALM_CHANGED);

                    } else {
                        // We're behind or on the same version as the worker thread

                        // we need to check if the received results cover all the current async RealmResults we had
                        // otherwise ignore this results & fire a new update that should include the new add RealmResults
                        // Missed async query will update with their own message (independently from grouped updates)
                        // in the mean time they are empty so advance_read will not impact them
//                        for (RealmResults<?> realmResults : asyncQueries.get().keySet()) {
//                            if (!result.updatedTableViews.containsKey(System.identityHashCode(realmResults))) {
//                                handler.sendEmptyMessage(REALM_CHANGED);
//                            }
//                        }

                        // no need to remove old pointers from TableView, since they're
                        // imperative TV, they will not rerun if the SharedGroup advance

                        // only advance if we're behind
                        if (compare != 0) {
                            // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                            RealmLog.d("REALM_UPDATE_ASYNC_QUERIES caller is behind  advance_read");
                            // refresh the Realm to the version provided by the worker thread
                            // (advanceRead to the latest version may cause a version mismatch error) preventing us
                            // from importing correctly the handover table view
                            transaction.advanceRead(result.versionID);
                        }

                        ArrayList<RealmResults<?>> callbacksToNotify = new ArrayList<RealmResults<?>>(result.updatedTableViews.size());
                        // use updated TableViews pointers for the existing async RealmResults
                        Set<Map.Entry<WeakReference<RealmResults<?>>, Long>> entries = result.updatedTableViews.entrySet();
                        for (Map.Entry<WeakReference<RealmResults<?>>, Long> query : entries) {
                            WeakReference<RealmResults<?>> weakRealmResults = query.getKey();
                            RealmResults<?> realmResults = weakRealmResults.get();
                            if (realmResults == null) {
                                asyncQueries.get().remove(weakRealmResults);

                            } else {
                                // retrieve the RealmResults here before we change the pointer
                                // that may affect the hashcode (we risk not being able to retrieve it back)
                                callbacksToNotify.add(realmResults);
                                RealmLog.d("REALM_UPDATE_ASYNC_QUERIES updating RealmResults " + weakRealmResults);
                                // update the instance with the new pointer
                                realmResults.swapTableViewPointer(query.getValue());
                                // it's dangerous to notify the callback about new results here
                                // since this callback may use another RealmResults not updated yet

                            }
                        }

                        // notify callbacks
//                        for (Integer key :
//                                result.updatedTableViews.keySet()) {
//                            RealmResults<?> realmResults = hashToInstance.get(key).get();
//                            if (null != realmResults) {
//                                // this needs to compute the hashcode again which is wrong given that we just updated the
//                                // pointer of RealmResults
//                                asyncQueries.get().get(realmResults).notifyUpdateCallback();
//                            }
//                        }
                        for (RealmResults<?> query: callbacksToNotify) {
                            query.notifyChangeListeners();
                        }
                        sendNotifications();
                        updateAsyncQueries = null;
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_FIND_FIRST: {
                    UpdateAsyncQueriesTask.Result result = (UpdateAsyncQueriesTask.Result) message.obj;
                    WeakReference<RealmObject> realmObjectWeakReference = (WeakReference<RealmObject>) result.updatedRow.keySet().toArray()[0];


//                    Long handoverRowPointer = args.getLong("pointer");
//                    SharedGroup.VersionID versionID = (SharedGroup.VersionID) args.getSerializable("version");
//                    WeakReference<RealmObject> realmObjectWeakReference= (WeakReference<RealmObject>) message.obj;

                    RealmObject realmObject = realmObjectWeakReference.get();
                    if (realmObject != null) {
                        SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                        int compare = callerVersionID.compareTo(result.versionID);
                        // we always query on the same version, there is no update (since advance_read refresh the accessor)
                        // only two uses case could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
                        if (compare == 0) { //same version import the handover
                            realmObject.onCompleted(result.updatedRow.get(realmObjectWeakReference));
                            asyncQueries.get().remove(realmObjectWeakReference);

                        } else if (compare > 0) { // the caller has advanced we need to
                            // retry against the current version of the caller
                            RealmQuery<?> realmQuery = asyncRealmObjects.get().get(realmObjectWeakReference);
                            ArrayList<UpdateAsyncQueriesTask.Entry> queryToUpdate = new ArrayList<UpdateAsyncQueriesTask.Entry>(1);
                            queryToUpdate.add(UpdateAsyncQueriesTask.Entry.newRealmObjectEntry(realmObjectWeakReference,
                                    new UpdateAsyncQueriesTask
                                            .UpdateQuery(realmQuery.handoverQueryPointer(sharedGroup.getNativePointer()),
                                            realmQuery.getArgument())));

                            Runnable task = new UpdateAsyncQueriesTask(handler, getConfiguration(), REALM_COMPLETED_ASYNC_FIND_FIRST, queryToUpdate, sharedGroup.getVersion());
                            updateAsyncQueries = asyncQueryExecutor.submit(task);

                        } else {
                            // should not happen, since the the baground thread position itself against the provided version
                            // and the caller thread can only go forward (advance_read)
                            throw new IllegalStateException("Caller thread behind the worker thread");
                        }
                    }

                    // TODO need to keep a separate WeakIdentityHashSet then remove the element after we delivered the Row
                    // also need to handle retry, worker behind/advanced, caller behind/advanced
                    // handle the case where the caller already forced a load

                    break;
                }
            }
            return true;
        }

