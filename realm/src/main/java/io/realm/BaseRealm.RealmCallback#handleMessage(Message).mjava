        @Override
        public boolean handleMessage(Message message) {
            switch (message.what) {
                case REALM_CHANGED: {
                    if (threadContainsAsyncQueries()) {
                        if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
                            // try to cancel any pending update since we're submitting a new one anyway
                            updateAsyncQueriesTask.cancel(true);
                            asyncQueryExecutor.getQueue().remove(updateAsyncQueriesTask);
                            RealmLog.d("REALM_CHANGED realm:"+ BaseRealm.this + " cancelling pending REALM_UPDATE_ASYNC_QUERIES updates");
                        }
                        RealmLog.d("REALM_CHANGED realm:"+ BaseRealm.this + " updating async queries, total: " + asyncRealmResults.size());
                        // prepare a QueryUpdateTask to current async queries in this thread
                        QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
                                .realmConfiguration(getConfiguration());
                        QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;

                        // we iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch)
                        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
                        while (iterator.hasNext()) {
                            Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>> entry = iterator.next();
                            WeakReference<RealmResults<? extends RealmObject>> weakReference = entry.getKey();
                            RealmResults<? extends RealmObject> realmResults = weakReference.get();
                            if (realmResults == null) {
                                // GC'd instance remove from the list
                                iterator.remove();

                            } else {
                                realmResultsQueryStep = updateQueryStep.add(weakReference,
                                        entry.getValue().handoverQueryPointer(),
                                        entry.getValue().getArgument());
                            }

                            // Note: we're passing an WeakRef of a RealmResults to another thread
                            //       this is safe as long as we don't invoke any of the RealmResults methods.
                            //       we're just using it as a Key in an IdentityHashMap (i.e doesn't call
                            //       AbstractList's hashCode, that require accessing objects from another thread)
                            //
                            //       watch out when you debug, as you're IDE try to evaluate RealmResults
                            //       which break the Thread confinement constraints.
                        }
                        if (realmResultsQueryStep != null) {
                            QueryUpdateTask queryUpdateTask = realmResultsQueryStep
                                    .sendToHandler(handler, REALM_UPDATE_ASYNC_QUERIES)
                                    .build();
                            updateAsyncQueriesTask = asyncQueryExecutor.submit(queryUpdateTask);
                        }

                    } else {
                        RealmLog.d("REALM_CHANGED realm:"+ BaseRealm.this + " no async queries, advance_read");
                        sharedGroupManager.advanceRead();
                        sendNotifications();
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_QUERY: {
                    // one async query has completed
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;

                    Set<WeakReference<RealmResults<? extends RealmObject>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
                    if (updatedTableViewsKeys.size() > 0) {
                        WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = updatedTableViewsKeys.iterator().next();

                        RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
                        if (realmResults == null) {
                            asyncRealmResults.remove(weakRealmResults);
                            RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] realm:"+ BaseRealm.this + " RealmResults GC'd ignore results");

                        } else {
                            SharedGroup.VersionID callerVersionID = sharedGroupManager.getVersion();
                            int compare = callerVersionID.compareTo(result.versionID);
                            if (compare == 0) {
                                // if the RealmResults is empty (has not completed yet) then use the value
                                // otherwise a task (grouped update) has already updated this RealmResults
                                if (!realmResults.isLoaded()) {
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ BaseRealm.this + " same versions, using results (RealmResults is not loaded)");
                                    // swap pointer
                                    realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                                    // notify callbacks
                                    realmResults.notifyChangeListeners();
                                } else {
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ BaseRealm.this + " ignoring result the RealmResults (is already loaded)");
                                }

                            } else if (compare > 0) {
                                // we have two use cases:
                                // 1- this RealmResults is not empty, this means that after we started the async
                                //    query, we received a REALM_CHANGE that triggered an update of all async queries
                                //    including the last async submitted, so no need to use the provided TableView pointer
                                //    (or the user forced the sync behaviour .load())
                                // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread
                                //    this could happen if the current thread advanced the shared_group (via a write or refresh)
                                //    this means that we need to rerun the query against a newer worker thread.

                                if (!realmResults.isLoaded()) { // UC2
                                    // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY " + weakRealmResults + "] , realm:"+ BaseRealm.this + " caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");

                                    RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
                                    QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                            .realmConfiguration(getConfiguration())
                                            .add(weakRealmResults,
                                                    query.handoverQueryPointer(),
                                                    query.getArgument())
                                            .sendToHandler(handler, REALM_COMPLETED_ASYNC_QUERY)
                                            .build();

                                    asyncQueryExecutor.submit(queryUpdateTask);

                                } else {
                                    // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ BaseRealm.this + " caller is more advanced & RealmResults is loaded ignore the outdated result");
                                }

                            } else {
                                // the caller thread is behind the worker thread,
                                // no need to rerun the query, since we're going to receive the update signal
                                // & batch update all async queries including this one
                                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ BaseRealm.this + " caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
                            }
                        }
                    }
                    break;
                }
                case REALM_UPDATE_ASYNC_QUERIES: {
                    // this is called once the background thread completed the update of the async queries
                    QueryUpdateTask.Result result
                            = (QueryUpdateTask.Result) message.obj;

                    SharedGroup.VersionID callerVersionID = sharedGroupManager.getVersion();
                    int compare = callerVersionID.compareTo(result.versionID);
                    if (compare > 0) {
                        RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ BaseRealm.this + " caller is more advanced, rerun updates");
                        // The caller is more advance than the updated queries ==>
                        // need to refresh them again (if there is still queries)
                        handler.sendEmptyMessage(REALM_CHANGED);

                    } else {
                        // We're behind or on the same version as the worker thread

                        // only advance if we're behind
                        if (compare != 0) {
                            // no need to remove old pointers from TableView, since they're
                            // imperative TV, they will not rerun if the SharedGroup advance

                            // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                            RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ BaseRealm.this + " caller is behind  advance_read");
                            // refresh the Realm to the version provided by the worker thread
                            // (advanceRead to the latest version may cause a version mismatch error) preventing us
                            // from importing correctly the handover table view
                            sharedGroupManager.advanceRead(result.versionID);
                        }

                        ArrayList<RealmResults<? extends RealmObject>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmObject>>(result.updatedTableViews.size());
                        // use updated TableViews pointers for the existing async RealmResults
                        for (Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, Long> query : result.updatedTableViews.entrySet()) {
                            WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = query.getKey();
                            RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
                            if (realmResults == null) {
                                // don't update GC'd instance
                                asyncRealmResults.remove(weakRealmResults);

                            } else {
                                // it's dangerous to notify the callback about new results before updating
                                // the pointers, because the callback may use another RealmResults not updated yet
                                // this is why we defer the notification until we're done updating all pointers

                                // TODO find a way to only notify callbacks if the underlying data changed compared
                                //      to the existing value(s) for this RealmResults (use a hashCode?)
                                callbacksToNotify.add(realmResults);

                                RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ BaseRealm.this + " updating RealmResults " + weakRealmResults);
                                // update the instance with the new pointer
                                realmResults.swapTableViewPointer(query.getValue());
                            }
                        }

                        for (RealmResults<? extends RealmObject> query : callbacksToNotify) {
                            query.notifyChangeListeners();
                        }

                        // notify listeners only when we advanced
                        if (compare != 0) {
                            sendNotifications();
                        }

                        updateAsyncQueriesTask = null;
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_FIND_FIRST: {
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
                    Set<WeakReference<RealmObject>> updatedRowKey = result.updatedRow.keySet();
                    if (updatedRowKey.size() > 0) {
                        WeakReference<RealmObject> realmObjectWeakReference = updatedRowKey.iterator().next();
                        RealmObject realmObject = realmObjectWeakReference.get();

                        if (realmObject != null) {
                            SharedGroup.VersionID callerVersionID = sharedGroupManager.getVersion();
                            int compare = callerVersionID.compareTo(result.versionID);
                            // we always query on the same version
                            // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
                            if (compare == 0) { //same version import the handover
                                realmObject.onCompleted(result.updatedRow.get(realmObjectWeakReference));
                                asyncRealmObjects.remove(realmObjectWeakReference);

                            } else if (compare > 0) {
                                // the caller has advanced we need to
                                // retry against the current version of the caller
                                RealmQuery<?> realmQuery = asyncRealmObjects.get(realmObjectWeakReference);

                                QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                        .realmConfiguration(getConfiguration())
                                        .addObject(realmObjectWeakReference,
                                                realmQuery.handoverQueryPointer(),
                                                realmQuery.getArgument())
                                        .sendToHandler(handler, REALM_COMPLETED_ASYNC_FIND_FIRST)
                                        .build();

                                asyncQueryExecutor.submit(queryUpdateTask);
                            } else {
                                // should not happen, since the the background thread position itself against the provided version
                                // and the caller thread can only go forward (advance_read)
                                throw new IllegalStateException("Caller thread behind the worker thread");
                            }
                        } // else: element GC'd in the meanwhile
                    }
                    break;
                }
            }
            return true;
        }

