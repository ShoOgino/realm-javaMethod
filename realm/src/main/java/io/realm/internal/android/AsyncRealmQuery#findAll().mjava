    /**
     * Find all objects that fulfill the query conditions.
     * Results will be posted to the callback instance {@link Realm.QueryCallback} asynchronously
     * If no objects match the condition, a list with zero objects is returned.
     *
     * @see io.realm.RealmResults
     */
    public RealmQuery.AsyncRequest findAll() {
        // will use the Looper of the caller thread to post the result
        Looper looper;
        if ((looper = Looper.myLooper()) != null) {
            eventHandler = new EventHandler(looper);
        } else if ((looper = Looper.getMainLooper()) != null) {
            eventHandler = new EventHandler(looper);
        } else {
            eventHandler = null;//FIXME define strategy/behaviour for regular JVM call
        }

        // We need a pointer to the caller Realm, to be able to handover the result to it
        final long callerSharedGroupNativePtr = callerRealm.getSharedGroupPointer();

        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
        // to perform the query
        final RealmConfiguration realmConfiguration = callerRealm.getConfiguration();
        //This call needs to be done on the caller's thread, since SG()->get_version_of_current_transaction is not thread safe
        final long[] callerSharedGroupVersion = callerRealm.getSharedGroupVersion();

        pendingQuery = asyncQueryExecutor.submit(new Runnable() {
            @Override
            public void run() {
                if (!Thread.currentThread().isInterrupted()) {
                    try {
                        Realm bgRealm = createOrRetrieveCachedWorkerRealm(realmConfiguration);
                        // Position the SharedGroup to the same version as the caller thread
                        // the call to SharedGroup->get_version_of_current_transaction is not thread safe
                        // it needs to happen on the caller's thread.
                        bgRealm.setSharedGroupAtVersion(callerSharedGroupVersion);
                        //TODO This will probably be replace by a kind of 'QueryBuilder'
                        //     that holds all the operations (predicates/filters) then
                        //     replay them here in this background thread. The current implementation
                        //     call Core for each step, we want to limit the overhead by sending one
                        //     single call to Core with all the parameters.

                        realmQueryAdapter = new RealmQueryAdapter<E>(bgRealm, clazz);
                        long tableViewPtr = realmQueryAdapter
                                .between(fieldName, from, to)
                                .findAll(bgRealm.getSharedGroupPointer());

                        if (IS_DEBUG && NB_ADVANCE_READ_SIMULATION-- > 0) {
                            // notify caller thread that we're about to post result to Handler
                            // (this is interesting in Unit Testing, as we can advance read to simulate
                            // a mismatch between the query result, and the current version of the Realm
                            eventHandler.sendEmptyMessage(EventHandler.MSG_ADVANCE_READ);
                        }

                        // send results to the caller thread's callback
                        if (!pendingQuery.isCancelled()) {
                            Bundle bundle = new Bundle(2);
                            bundle.putLong(EventHandler.TABLE_VIEW_POINTER_ARG, tableViewPtr);
                            bundle.putLong(EventHandler.CALLER_SHARED_GROUP_POINTER_ARG, callerSharedGroupNativePtr);

                            Message msg = eventHandler.obtainMessage(EventHandler.MSG_SUCCESS);
                            msg.setData(bundle);
                            eventHandler.sendMessage(msg);
                        }

                    } catch (Exception e) {
                        if (!pendingQuery.isCancelled()) {
                            Message msg = eventHandler.obtainMessage(EventHandler.MSG_ERROR, e);
                            eventHandler.sendMessage(msg);
                        }
                    }
                }
            }
        });

        return new RealmQuery.AsyncRequest(pendingQuery);
    }

