    /**
     * Find all objects that fulfill the query conditions.
     * Results will be posted to the callback instance {@link Realm.QueryCallback} asynchronously
     * If no objects match the condition, a list with zero objects is returned.
     *
     * @see io.realm.RealmResults
     */
    public RealmQuery.AsyncRequest findAll() {
        // will use the Looper of the caller thread to post the result
        Looper looper;
        if ((looper = Looper.myLooper()) != null) {
            eventHandler = new EventHandler(looper);
        } else if ((looper = Looper.getMainLooper()) != null) {
            eventHandler = new EventHandler(looper);
        } else {
            eventHandler = null;//FIXME define strategy/behaviour for regular JVM call
        }

        // We need a pointer to the caller Realm, to be able to handover the result to it
        final long callerSharedGroupNativePtr = callerRealm.getSharedGroupPointer();

        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
        // to perform the query
        final RealmConfiguration realmConfiguration = callerRealm.getConfiguration();

        pendingQuery = asyncQueryExecutor.submit(new Runnable() {
            @Override
            public void run() {
                if (!Thread.currentThread().isInterrupted()) {
                    try {
                        Realm bgRealm = Realm.getInstance(realmConfiguration);

                        //TODO This will probably be replace by a kind of 'QueryBuilder'
                        //     that holds all the operations (predicates/filters) then
                        //     replay them here in this background thread. The current implementation
                        //     call Core for each step, we want to limit the overhead by sending one
                        //     single call to Core with all the parameters.

                        TableView tv = new RealmQueryAdapter<E>(bgRealm, clazz)
                                .between(fieldName, from, to)
                                .findAll(callerSharedGroupNativePtr, bgRealm.getSharedGroupPointer());

                        bgRealm.close();

                        // send results to the caller thread's callback
                        if (!pendingQuery.isCancelled()) {
                            Message msg = eventHandler.obtainMessage(EventHandler.MSG_SUCCESS, tv);
                            eventHandler.sendMessage(msg);
                        }

                    } catch (Exception e) {
                        if (!pendingQuery.isCancelled()) {
                            Message msg = eventHandler.obtainMessage(EventHandler.MSG_ERROR, e);
                            eventHandler.sendMessage(msg);
                        }
                    }
                }
            }
        });

        return new RealmQuery.AsyncRequest(pendingQuery);
    }

