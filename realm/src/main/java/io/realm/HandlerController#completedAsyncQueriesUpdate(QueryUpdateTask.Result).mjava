    private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
        SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
        int compare = callerVersionID.compareTo(result.versionID);
        if (compare > 0) {
            RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, rerun updates");
            // The caller is more advance than the updated queries ==>
            // need to refresh them again (if there is still queries)
            realm.handler.sendEmptyMessage(Realm.REALM_CHANGED);

        } else {
            // We're behind or on the same version as the worker thread

            // only advance if we're behind
            if (compare != 0) {
                // no need to remove old pointers from TableView, since they're
                // imperative TV, they will not rerun if the SharedGroup advance

                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " caller is behind  advance_read");
                // refresh the Realm to the version provided by the worker thread
                // (advanceRead to the latest version may cause a version mismatch error) preventing us
                // from importing correctly the handover table view
                realm.sharedGroupManager.advanceRead(result.versionID);
            }

            ArrayList<RealmResults<? extends RealmObject>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmObject>>(result.updatedTableViews.size());
            // use updated TableViews pointers for the existing async RealmResults
            for (Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, Long> query : result.updatedTableViews.entrySet()) {
                WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = query.getKey();
                RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
                if (realmResults == null) {
                    // don't update GC'd instance
                    asyncRealmResults.remove(weakRealmResults);

                } else {
                    // it's dangerous to notify the callback about new results before updating
                    // the pointers, because the callback may use another RealmResults not updated yet
                    // this is why we defer the notification until we're done updating all pointers

                    // TODO find a way to only notify callbacks if the underlying data changed compared
                    //      to the existing value(s) for this RealmResults (use a hashCode?)
                    callbacksToNotify.add(realmResults);

                    RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
                    // update the instance with the new pointer
                    realmResults.swapTableViewPointer(query.getValue());
                }
            }

            for (RealmResults<? extends RealmObject> query : callbacksToNotify) {
                query.notifyChangeListeners();
            }

            // notify listeners only when we advanced
            if (compare != 0) {
                realm.sendNotifications();
            }

            updateAsyncQueriesTask = null;
        }
    }

