    /**
     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously from a worker thread
     * @param transaction {@link io.realm.Realm.Transaction} to execute.
     * @param callback optional, to receive the result of this query
     * @return A {@link io.realm.RealmQuery.Request} representing a cancellable task
     */
    public RealmQuery.Request executeTransaction(final Transaction transaction, @Nullable final Transaction.Callback callback) {
        if (transaction == null)
            throw new IllegalArgumentException("transaction should not be null");

        // will use the Looper of the caller thread to post the result
        final Handler handler = new Handler();

        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
        // to perform the transaction
        final RealmConfiguration realmConfiguration = getConfiguration();

        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
            @Override
            public void run() {
                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);

                if (!Thread.currentThread().isInterrupted()) {
                    Realm bgRealm = Realm.getInstance(realmConfiguration);
                    bgRealm.beginTransaction();
                    try {
                        transaction.execute(bgRealm);

                        if (!Thread.currentThread().isInterrupted()) {
                            bgRealm.commitTransaction();
                            if (callback != null) {
                                handler.post(new Runnable() {
                                    @Override
                                    public void run() {
                                        callback.onSuccess();
                                    }
                                });
                            }
                        } else {
                            bgRealm.cancelTransaction();
                        }

                    } catch (final RuntimeException e) {
                        bgRealm.cancelTransaction();
                        if (callback != null && !Thread.currentThread().isInterrupted()) {
                            handler.post(new Runnable() {
                                @Override
                                public void run() {
                                    callback.onError(e);
                                }
                            });
                        }
                    } catch (final Error e) {
                        bgRealm.cancelTransaction();
                        if (callback != null && !Thread.currentThread().isInterrupted()) {
                            handler.post(new Runnable() {
                                @Override
                                public void run() {
                                    callback.onError(e);
                                }
                            });
                        }
                    } finally {
                        bgRealm.close();
                    }
                }
            }
        });

        return new RealmQuery.Request(pendingQuery);
    }

