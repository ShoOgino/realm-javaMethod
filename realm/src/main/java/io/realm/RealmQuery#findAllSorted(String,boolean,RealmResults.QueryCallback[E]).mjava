    /**
     * Similar to {@link #findAllSorted(String, boolean)} but runs asynchronously from a worker thread
     *
     * @param fieldName     the field name to sort by.
     * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
     *                      if <code>SORT_ORDER_DESCENDING</code>
     * @param callback      to receive the result of this query
     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
     * a list with zero objects is returned.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
    public Request findAllSorted(String fieldName, boolean sortAscending, RealmResults.QueryCallback<E> callback) {
        // capture the sorting properties in case we want to retry the query
        this.callbackRealmResults = callback;
        this.fieldName = fieldName;
        this.sortAscending = sortAscending;

        // will use the Looper of the caller thread to post the result
        final Handler handler = new EventHandler(callback);

        // We need a pointer to the caller Realm, to be able to handover the result to it
        final long callerSharedGroupNativePtr = realm.getSharedGroupPointer();

        // Handover the query (to be used by a worker thread)
        handoverQueryPtr = query.handoverQuery(callerSharedGroupNativePtr);

        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
        // to perform the query
        final RealmConfiguration realmConfiguration = realm.getConfiguration();

        final TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        final Long columnIndex = columns.get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
            @Override
            public void run() {
                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
                if (!Thread.currentThread().isInterrupted() && (asyncRequest == null || !asyncRequest.isCancelled())) {
                    Realm bgRealm = null;

                    try {
                        //TODO Once SharedGroup is thread safe, start reusing a cached instance
                        //     of a worker Realm to avoid the cost of opening/closing a SharedGroup
                        //     for each query
                        bgRealm = Realm.getInstance(realmConfiguration);

                        // Run the query & handover the table view for the caller thread
                        handoverTableViewPtr = query.findAllSortedWithHandover(bgRealm.getSharedGroupPointer(), bgRealm.sharedGroup.getNativeReplicationPointer(), handoverQueryPtr, columnIndex, (order == TableView.Order.ascending));
                        // save query arguments (for future update)
                        argumentsHolder =  new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_SORTED);
                        argumentsHolder.columnIndex = columnIndex;
                        argumentsHolder.ascending = (order == TableView.Order.ascending);


                        handoverQueryPtr = -1;
                        if (IS_DEBUG && NB_ADVANCE_READ_SIMULATION-- > 0) {
                            // notify caller thread that we're about to post result to Handler
                            // (this is relevant in Unit Testing, as we can advance read to simulate
                            // a mismatch between the query result, and the current version of the Realm
                            handler.sendMessage(handler.obtainMessage(
                                    EventHandler.MSG_ADVANCE_READ,
                                    EventHandler.FIND_ALL_SORTED_QUERY, 0));

                        }

                        // send results to the caller thread's callback
                        Bundle bundle = new Bundle(2);
                        bundle.putLong(EventHandler.QUERY_RESULT_POINTER_ARG, handoverTableViewPtr);
                        bundle.putLong(EventHandler.CALLER_SHARED_GROUP_POINTER_ARG, callerSharedGroupNativePtr);

                        Message message = handler.obtainMessage(EventHandler.MSG_SUCCESS);
                        message.arg1 = EventHandler.FIND_ALL_SORTED_QUERY;
                        message.setData(bundle);
                        handler.sendMessage(message);

                    } catch (BadVersionException e) {
                        handler.sendMessage(handler.obtainMessage(
                                EventHandler.MSG_UNREACHABLE_VERSION,
                                EventHandler.FIND_ALL_SORTED_QUERY, 0));

                    } catch (Exception e) {
                        handler.sendMessage(handler.obtainMessage(
                                EventHandler.MSG_ERROR,
                                EventHandler.FIND_ALL_SORTED_QUERY, 0, e));

                    } finally {
                        if (null != bgRealm) {
                            bgRealm.close();
                        }
                    }
                } else {
                    releaseHandoverResources();
                }
            }
        });
        if (null != asyncRequest) {
            // update current reference, since retrying the query will
            // submit a new Runnable, hence the need to update the user
            // with the new Future<?> reference.
            asyncRequest.setPendingQuery(pendingQuery);

        } else { //First run
            asyncRequest = new Request(pendingQuery);
        }
        return asyncRequest;
    }

