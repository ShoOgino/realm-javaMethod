    private static synchronized Realm createAndValidate(RealmConfiguration config, boolean validateSchema, boolean autoRefresh) {
        String absolutePath = config.getAbsolutePathToRealm();
        byte[] key = config.getKey();
        int id = absolutePath.hashCode();
        Map<Integer, Integer> localRefCount = referenceCount.get();
        Integer references = localRefCount.get(id);
        if (references == null) {
            references = 0;
        }
        if (references == 0) {
            AtomicInteger counter = openRealms.get(id);
            if (counter == null) {
                if (config.isDeleteRealmBeforeOpening()) {
                    deleteRealmFile(config);
                }
                openRealms.put(id, new AtomicInteger(1));
            } else {
                counter.incrementAndGet();
            }

        }
        Map<Integer, Realm> realms = realmsCache.get();
        Realm realm = realms.get(id);

        if (realm != null) {
            if (!Arrays.equals(realm.key, key)) {
                throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
            }
            localRefCount.put(id, references + 1);
            return realm;
        }

        // Create new Realm and cache it. All exception code paths must close the Realm otherwise we risk serving
        // faulty cache data.
        realm = new Realm(absolutePath, key, autoRefresh);
        realms.put(id, realm);
        realmsCache.set(realms);
        localRefCount.put(id, references + 1);

        if (validateSchema) {
            try {
                initializeRealm(realm, config);
            } catch (RuntimeException e) {
                realm.close();
                throw e;
            }
        }

        return realm;
    }

