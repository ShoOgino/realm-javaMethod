    public RealmResults<E> findAllSortedAsync(String fieldName, boolean sortAscending) {
        final TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        final Long columnIndex = columns.get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        // capture the query arguments for future retries & update
        argumentsHolder =  new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_SORTED);
        argumentsHolder.ascending = sortAscending;
        argumentsHolder.columnIndex = columnIndex;

        // will use the Looper of the caller Realm to post the result
        final Handler handler = realm.getHandler();

        // Handover the query (to be used by a worker thread)
        handoverQueryPtr = query.handoverQuery(realm.getSharedGroupPointer());

        // We need to use the same configuration to open a background SharedGroup to perform the query
        final RealmConfiguration realmConfiguration = realm.getConfiguration();

        RealmResults<E> realmResults = new RealmResults<E>(realm, query, clazz);
        final WeakReference<RealmResults<?>> weakRealmResults = new WeakReference<RealmResults<?>>(realmResults);
        Realm.asyncQueries.get().put(weakRealmResults, this);

        final Future<Long> pendingQuery = asyncQueryExecutor.submit(new Callable<Long>() {
            @Override
            public Long call() throws Exception {
                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
                if (!Thread.currentThread().isInterrupted() && (asyncRequest == null || !asyncRequest.isCancelled())) {
                    SharedGroup sharedGroup = null;

                    try {
                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
                                true, realmConfiguration.getDurability(),
                                realmConfiguration.getEncryptionKey());

                        // Run the query & handover the table view for the caller thread
                        handoverTableViewPtr = query.findAllSortedWithHandover(sharedGroup.getNativePointer(), sharedGroup.getNativeReplicationPointer(), handoverQueryPtr, columnIndex, (order == TableView.Order.ascending));

                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResults();
                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPtr);
                        result.versionID = sharedGroup.getVersion();

                        if (handler.getLooper().getThread().isAlive()) {
                            Message message = handler.obtainMessage(Realm.REALM_COMPLETED_ASYNC_QUERY, result);
                            handler.sendMessage(message);
                        }

                        return handoverTableViewPtr;

                    } catch (BadVersionException e) {
                        e.printStackTrace();
                        return INVALID_TABLE_VIEW_POINTER;

                    } catch (Exception e) {
                        e.printStackTrace();
                        return INVALID_TABLE_VIEW_POINTER;

                    } finally {
                        if (sharedGroup != null) {
                            sharedGroup.close();
                        }
                    }
                } else {
                    //TODO is there any releaseHandoverResources() to release?

                }
                return INVALID_TABLE_VIEW_POINTER;
            }
        });
        realmResults.setPendingQuery(pendingQuery);
        return realmResults;
    }

