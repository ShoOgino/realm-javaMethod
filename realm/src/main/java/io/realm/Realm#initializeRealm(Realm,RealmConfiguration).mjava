    @SuppressWarnings("unchecked")
    private static void initializeRealm(Realm realm, RealmConfiguration config) {
        Class<?> validationClass;
        try {
            validationClass = Class.forName("io.realm.ValidationList");
        } catch (ClassNotFoundException e) {
            throw new RealmException("Could not find the generated ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        Method getProxyClassesMethod;
        try {
            getProxyClassesMethod = validationClass.getMethod("getProxyClasses");
        } catch (NoSuchMethodException e) {
            throw new RealmException("Could not find the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        List<String> proxyClasses;
        try {
            proxyClasses = (List<String>) getProxyClassesMethod.invoke(null);
        } catch (IllegalAccessException e) {
            throw new RealmException("Could not execute the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        } catch (InvocationTargetException e) {
            throw new RealmException("An exception was thrown in the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }

        // Custom schema overrides any schema already defined
        Set<Class<? extends RealmObject>> customSpec = config.getSchema();
        if (customSpec.size() > 0) {
            proxyClasses = new ArrayList<String>();
            for (Class<? extends RealmObject> clazz : customSpec) {
                proxyClasses.add(clazz.getName());
            }
        }

        long version = realm.getVersion();
        boolean commitNeeded = false;
        try {
            realm.beginTransaction();
            if (version == UNVERSIONED) {
                commitNeeded = true;
                realm.setVersion(config.getSchemaVersion());
            }
            for (String className : proxyClasses) {
                String[] splitted = className.split("\\.");
                String modelClassName = splitted[splitted.length - 1];
                String generatedClassName = getProxyClassName(modelClassName);

                // Verify that there is a proxy class for each supported model class
                Class<?> generatedClass;
                try {
                    generatedClass = Class.forName(generatedClassName);
                } catch (ClassNotFoundException e) {
                    throw new RealmException("Could not find the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }

                // if not versioned, create table
                if (version == UNVERSIONED) {
                    Method initTableMethod;
                    try {
                        initTableMethod = generatedClass.getMethod("initTable", new Class[]{ImplicitTransaction.class});
                    } catch (NoSuchMethodException e) {
                        throw new RealmException("Could not find the initTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                    try {
                        initTableMethod.invoke(null, realm.transaction);
                        commitNeeded = true;
                    } catch (IllegalAccessException e) {
                        throw new RealmException("Could not execute the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    } catch (InvocationTargetException e) {
                        throw new RealmException("An exception was thrown in the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                }

                // validate created table
                Method validateMethod;
                try {
                    validateMethod = generatedClass.getMethod("validateTable", new Class[]{ImplicitTransaction.class});
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the validateTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                try {
                    validateMethod.invoke(null, realm.transaction);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                } catch (InvocationTargetException e) {
                    throw new RealmMigrationNeededException(realm.getPath(), e.getMessage(), e);
                }

                // Populate the columnIndices table
                Method columnIndiciesMethod;
                try {
                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                Map<String,Long> indices;
                try {
                    //noinspection unchecked
                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                } catch (InvocationTargetException e) {
                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                }
                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
            }
        } finally {
            if (commitNeeded) {
                realm.commitTransaction();
            } else {
                realm.cancelTransaction();
            }
        }
    }

